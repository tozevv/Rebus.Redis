<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rebus</name>
    </assembly>
    <members>
        <member name="T:Rebus.Bus.AmbientTransactionContext">
            <summary>
            Implementation of <see cref="T:Rebus.ITransactionContext"/> that is tied to an ambient .NET transaction.
            </summary>
        </member>
        <member name="T:Rebus.ITransactionContext">
            <summary>
            Defines a context of a transaction, allowing transports to hook operations up on transaction events
            </summary>
        </member>
        <member name="P:Rebus.ITransactionContext.IsTransactional">
            <summary>
            Indicates whether the current context is actually transactional. If it is not transactional,
            the dictionary will be very short-lived, and you should not subscribe to any events.
            </summary>
        </member>
        <member name="P:Rebus.ITransactionContext.Item(System.String)">
            <summary>
            Gives access to a dictionary of stuff that will be kept for the duration of the transaction.
            </summary>
        </member>
        <member name="E:Rebus.ITransactionContext.DoCommit">
            <summary>
            Will be raised when it is time to commit the transaction. The transport should do its final
            commit work when this event is raised.
            </summary>
        </member>
        <member name="E:Rebus.ITransactionContext.DoRollback">
            <summary>
            Will be raised in the event that the transaction should be rolled back.
            </summary>
        </member>
        <member name="E:Rebus.ITransactionContext.BeforeCommit">
            <summary>
            Will be raised before doing the actual commit
            </summary>
        </member>
        <member name="E:Rebus.ITransactionContext.AfterRollback">
            <summary>
            Will be raised after a transaction has been rolled back
            </summary>
        </member>
        <member name="E:Rebus.ITransactionContext.Cleanup">
            <summary>
            Will be raised after all work is done, allowing you to clean up resources etc.
            </summary>
        </member>
        <member name="M:Rebus.Bus.AmbientTransactionContext.#ctor">
            <summary>
            Constructs the context, enlists it in the ambient transaction, and sets itself as the current context in <see cref="T:Rebus.Bus.TransactionContext"/>.
            </summary>
        </member>
        <member name="M:Rebus.Bus.AmbientTransactionContext.Prepare(System.Transactions.PreparingEnlistment)">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="M:Rebus.Bus.AmbientTransactionContext.Commit(System.Transactions.Enlistment)">
            <summary>
            Performs necessary commit actions, clearing the current <see cref="T:Rebus.Bus.TransactionContext"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.AmbientTransactionContext.Rollback(System.Transactions.Enlistment)">
            <summary>
            Performs necessary rollback actions, clearing the current <see cref="T:Rebus.Bus.TransactionContext"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.AmbientTransactionContext.InDoubt(System.Transactions.Enlistment)">
            <summary>
            Does nothing
            </summary>
        </member>
        <member name="E:Rebus.Bus.AmbientTransactionContext.DoCommit">
            <summary>
            Will be raised when it is time to commit the transaction. The transport should do its final
            commit work when this event is raised.
            </summary>
        </member>
        <member name="E:Rebus.Bus.AmbientTransactionContext.BeforeCommit">
            <summary>
            Will be raised before doing the actual commit
            </summary>
        </member>
        <member name="E:Rebus.Bus.AmbientTransactionContext.DoRollback">
            <summary>
            Will be raised in the event that the transaction should be rolled back.
            </summary>
        </member>
        <member name="E:Rebus.Bus.AmbientTransactionContext.AfterRollback">
            <summary>
            Will be raised after a transaction has been rolled back
            </summary>
        </member>
        <member name="E:Rebus.Bus.AmbientTransactionContext.Cleanup">
            <summary>
            Will be raised after all work is done, allowing you to clean up resources etc.
            </summary>
        </member>
        <member name="P:Rebus.Bus.AmbientTransactionContext.IsTransactional">
            <summary>
            Returns true because we're always transactional when we're enlisted in an ambient transaction
            </summary>
        </member>
        <member name="P:Rebus.Bus.AmbientTransactionContext.Item(System.String)">
            <summary>
            Gives access to a dictionary of stuff that will be kept for the duration of the transaction.
            </summary>
        </member>
        <member name="T:Rebus.Bus.BackoffHelper">
            <summary>
            I can help you wait, especially if you want to wait e.g. for some kind of increasing amount of time.
            </summary>
        </member>
        <member name="F:Rebus.Bus.BackoffHelper.waitAction">
            <summary>
            So we can replace it with something else e.g. during tests
            </summary>
        </member>
        <member name="M:Rebus.Bus.BackoffHelper.Reset">
            <summary>
            Resets the backoff helper which means that waiting will start over from the beginning of the sequence of wait times
            </summary>
        </member>
        <member name="M:Rebus.Bus.BackoffHelper.Wait">
            <summary>
            Waits the time specified next in the sequence
            </summary>
        </member>
        <member name="M:Rebus.Bus.BackoffHelper.Wait(System.Action{System.TimeSpan})">
            <summary>
            Waits the time specified next in the sequence, invoking the callback with the time that will be waited
            </summary>
        </member>
        <member name="T:Rebus.Bus.IHandleDeferredMessage">
            <summary>
            Service that helps re-dispatching deferred messages (i.e. when the payload of the <see cref="T:Rebus.Messages.TimeoutReply"/> is
            deserialized into a message, that message is handled by the re-dispatcher)
            </summary>
        </member>
        <member name="T:Rebus.Bus.Dispatcher">
            <summary>
            Implements stuff that must happen when handling one single message.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Dispatcher.#ctor(Rebus.IStoreSagaData,Rebus.IActivateHandlers,Rebus.IStoreSubscriptions,Rebus.IInspectHandlerPipeline,Rebus.Bus.IHandleDeferredMessage,Rebus.Timeout.IStoreTimeouts)">
            <summary>
            Constructs the dispatcher with the specified instances to store and retrieve saga data,
            create message handlers, store and retrieve subscriptions, and to inspect and
            possibly rearrange the handler pipeline.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Dispatcher.Dispatch``1(``0)">
            <summary>
            Main entry point of the dispatcher. Dispatches the given message, doing handler
            lookup etc. Any exceptions thrown will bubble up.
            </summary>
        </member>
        <member name="M:Rebus.Bus.Dispatcher.DispatchToHandler``1(``0,Rebus.IHandleMessages{``0})">
            <summary>
              Private dispatcher method that gets invoked only via reflection.
            </summary>
        </member>
        <member name="T:Rebus.Bus.DueTimeoutScheduler">
            <summary>
            Responsible for periodically checking the timeout storage for due timeouts in the given implementation of <see cref="T:Rebus.Timeout.IStoreTimeouts"/>.
            Due timeouts will result in a <see cref="T:Rebus.Messages.TimeoutReply"/> which will be dispatched using the given implementation of <see cref="T:Rebus.Bus.IHandleDeferredMessage"/>.
            </summary>
        </member>
        <member name="T:Rebus.Bus.ErrorTracker">
            <summary>
            Implements logic to track failed message deliveries and decide when to consider messages poisonous.
            </summary>
        </member>
        <member name="T:Rebus.Bus.IErrorTracker">
            <summary>
            <see cref="T:Rebus.Bus.RebusBus"/> will use its <see cref="T:Rebus.Bus.IErrorTracker"/> to track failed delivery attempts.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IErrorTracker.StopTracking(System.String)">
            <summary>
            Stops tracking the message with the specified ID. If the message is not
            being tracked, nothing happens.
            </summary>
            <param name="id">ID of message to stop tracking</param>
        </member>
        <member name="M:Rebus.Bus.IErrorTracker.MessageHasFailedMaximumNumberOfTimes(System.String)">
            <summary>
            Determines whether the message with the specified ID has failed
            "enough time"
            </summary>
            <param name="id">ID of message to check</param>
            <returns>Whether the message has failed too many times</returns>
        </member>
        <member name="M:Rebus.Bus.IErrorTracker.GetErrorText(System.String)">
            <summary>
            Gets the error messages tracked so far for the message with the specified ID.
            </summary>
            <param name="id">ID of message whose error messages to get</param>
            <returns>Concatenated string of the tracked error messages</returns>
        </member>
        <member name="M:Rebus.Bus.IErrorTracker.TrackDeliveryFail(System.String,System.Exception)">
            <summary>
            Increments the fail count for this particular message, and starts tracking
            the message if it is not already being tracked.
            </summary>
            <param name="id">ID of the message to track</param>
            <param name="exception">The exception that was caught, thus resulting in wanting to track this message</param>
        </member>
        <member name="M:Rebus.Bus.IErrorTracker.GetPoisonMessageInfo(System.String)">
            <summary>
            Retrieves the poison message information collected so far for the message with the specfied id.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IErrorTracker.SetMaxRetriesFor``1(System.Int32)">
            <summary>
            Sets the maximum number of retries for some specific exception type
            </summary>
        </member>
        <member name="P:Rebus.Bus.IErrorTracker.ErrorQueueAddress">
            <summary>
            Returns the fully qualified address of the error queue to which messages should be forwarded in
            the event that they exceed the accepted number of failed delivery attempts.
            </summary>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.#ctor(System.TimeSpan,System.TimeSpan,System.String)">
            <summary>
            Constructs the error tracker with the given settings
            </summary>
            <param name="messageTrackerMaxAge">How long messages will be supervised by the ErrorTracker</param>
            <param name="expiredMessageTrackersCheckInterval">This is the interval that will last between checking whether delivery attempts have been tracked for too long</param>
            <param name="errorQueueAddress">This is the address of the error queue to which messages should be forwarded whenever they are deemed poisonous</param>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.#ctor(System.String)">
            <summary>
            Default constructor which sets the messageTrackerMaxAge to 1 day
            </summary>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.TrackDeliveryFail(System.String,System.Exception)">
            <summary>
            Increments the fail count for this particular message, and starts tracking
            the message if it is not already being tracked.
            </summary>
            <param name="id">ID of the message to track</param>
            <param name="exception">The exception that was caught, thus resulting in wanting to track this message</param>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.StopTracking(System.String)">
            <summary>
            Stops tracking the message with the specified ID. If the message is not
            being tracked, nothing happens.
            </summary>
            <param name="id">ID of message to stop tracking</param>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.GetErrorText(System.String)">
            <summary>
            Gets the error messages tracked so far for the message with the specified ID.
            </summary>
            <param name="id">ID of message whose error messages to get</param>
            <returns>Concatenated string of the tracked error messages</returns>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.GetPoisonMessageInfo(System.String)">
            <summary>
            Retrieves information about caught exceptions for the message with the
            given id.
            </summary>
            <param name="id">ID of message whose poison message information to get</param>
            <returns>Information about the poison message</returns>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.SetMaxRetriesFor``1(System.Int32)">
            <summary>
            Sets the maximum number of retries for some specific exception type
            </summary>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.MessageHasFailedMaximumNumberOfTimes(System.String)">
            <summary>
            Determines whether the message with the specified ID has failed
            "enough time"
            </summary>
            <param name="id">ID of message to check</param>
            <returns>Whether the message has failed too many times</returns>
        </member>
        <member name="M:Rebus.Bus.ErrorTracker.Dispose">
            <summary>
            Disposes the error tracker
            </summary>
        </member>
        <member name="P:Rebus.Bus.ErrorTracker.ErrorQueueAddress">
            <summary>
            Gets the globally addressable address of the error queue
            </summary>
        </member>
        <member name="P:Rebus.Bus.ErrorTracker.MaxRetries">
            <summary>
            Indicates how many times a message by default will be retried before it is moved to the error queue
            </summary>
        </member>
        <member name="T:Rebus.Bus.PoisonMessageInfo">
            <summary>
            Represents a message and information about exceptions that have been caught while attempting
            to process the message.
            </summary>
        </member>
        <member name="P:Rebus.Bus.PoisonMessageInfo.Id">
            <summary>
            The id of the transport message.
            </summary>
        </member>
        <member name="P:Rebus.Bus.PoisonMessageInfo.Exceptions">
            <summary>
            Collection of exceptions caught at specific times while processing the message.
            </summary>
        </member>
        <member name="T:Rebus.Bus.IMulticastTransport">
            <summary>
            Adds to <see cref="T:Rebus.IDuplexTransport"/> the ability to send to multiple recipients at
            once by using pub sub messaging. This implies that the transport can somehow persist
            subscriptions and take care of routing to subscribers.
            </summary>
        </member>
        <member name="T:Rebus.IDuplexTransport">
            <summary>
            Interface of something that is capable of sending and receiving messages at the same time, using the
            same channel type thus allowing it to send messages to itself.
            </summary>
        </member>
        <member name="T:Rebus.ISendMessages">
            <summary>
            Interface of something that is capable of sending a <see cref="T:Rebus.TransportMessageToSend"/> somewhere.
            </summary>
        </member>
        <member name="M:Rebus.ISendMessages.Send(System.String,Rebus.TransportMessageToSend,Rebus.ITransactionContext)">
            <summary>
            Sends the specified <see cref="T:Rebus.TransportMessageToSend"/> to the endpoint with the specified input queue name,
            enlisting in the specified <see cref="T:Rebus.ITransactionContext"/>.
            </summary>
        </member>
        <member name="T:Rebus.IReceiveMessages">
            <summary>
            Interface of something that is capable of receiving messages. If no message is available,
            null should be returned. If the bus is configured to run with multiple threads, this one
            should be reentrant.
            </summary>
        </member>
        <member name="M:Rebus.IReceiveMessages.ReceiveMessage(Rebus.ITransactionContext)">
            <summary>
            Attempt to receive the next available message. Should return null if no message is available.
            </summary>
        </member>
        <member name="P:Rebus.IReceiveMessages.InputQueue">
            <summary>
            Gets the name of this receiver's input queue - i.e. this is the queue that this receiver
            will pull messages from.
            </summary>
        </member>
        <member name="P:Rebus.IReceiveMessages.InputQueueAddress">
            <summary>
            Gets the globally accessible adddress of this receiver's input queue - i.e. this would probably
            be the input queue in some form, possible qualified by machine name or something similar.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IMulticastTransport.Subscribe(System.Type,System.String)">
            <summary>
            Subscribes the specified input queue address to messages of the specified type
            </summary>
        </member>
        <member name="M:Rebus.Bus.IMulticastTransport.Unsubscribe(System.Type,System.String)">
            <summary>
            Unsubscribes the specified input queue address from messages of the specified type
            </summary>
        </member>
        <member name="M:Rebus.Bus.IMulticastTransport.GetEventName(System.Type)">
            <summary>
            Gets a proper event name for the published event of the specified type.
            </summary>
        </member>
        <member name="P:Rebus.Bus.IMulticastTransport.ManagesSubscriptions">
            <summary>
            Indicates whether this multicast-capable transport IS in fact supposed to do multicast
            </summary>
        </member>
        <member name="T:Rebus.Bus.IMutateIncomingMessages">
            <summary>
            Service that is responsible for running message mutators on incoming messages
            </summary>
        </member>
        <member name="T:Rebus.Bus.IncomingMessageMutatorPipeline">
            <summary>
            Implementation that mutates incoming messages by running the list of message
            mutators from the current <see cref="T:Rebus.IRebusEvents"/> in reverse
            </summary>
        </member>
        <member name="T:Rebus.Bus.IUnitOfWork">
            <summary>
            Implement this in your own flavor to let Rebus control how your transaction is comitted/aborted.
            If your commit fails, and that requires <seealso cref="M:Rebus.Bus.IUnitOfWork.Abort"/> to be called, please do it yourself.
            Also, if you're using multiple units of work, please note that Rebus can't take any kinds of responsibility
            of what happens in the event that the last commit fails. 
            </summary>
        </member>
        <member name="M:Rebus.Bus.IUnitOfWork.Commit">
            <summary>
            Implement your commit logic here. Your commit logic should throw in the event that it cannot do its thing.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IUnitOfWork.Abort">
            <summary>
            Implement your rollback logic here. If your rollback logic must be called in the event that the commit fails,
            you must do so yourself.
            </summary>
        </member>
        <member name="T:Rebus.Bus.IUnitOfWorkManager">
            <summary>
            Implement this and install an instance in order to hook into Rebus' unit of work. The unit of work
            will be created right after the message context has been established, thus allowing the unit
            of work to access the context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.IUnitOfWorkManager.Create">
            <summary>
            Return an instance of your implementation of <see cref="T:Rebus.Bus.IUnitOfWork"/>
            </summary>
        </member>
        <member name="T:Rebus.Bus.NoTransaction">
            <summary>
            Transaction context that really means "no transaction". Sort of a null object implementation
            of a transaction context.
            </summary>
        </member>
        <member name="M:Rebus.Bus.NoTransaction.#ctor">
            <summary>
            Constructs the context and explicitly does NOT set itself as current in <see cref="T:Rebus.Bus.TransactionContext"/>, because that would not make sense...
            i.e. when would the "context" end when there's no transaction? The answer is that the <see cref="T:Rebus.Bus.NoTransaction"/> implementation of
            <see cref="T:Rebus.ITransactionContext"/> must never be set as the current transaction context, it must always be constructed when it must be used
            </summary>
        </member>
        <member name="M:Rebus.Bus.NoTransaction.Dispose">
            <summary>
            Detaches this transaction context from the thread
            </summary>
        </member>
        <member name="P:Rebus.Bus.NoTransaction.IsTransactional">
            <summary>
            Return false beause the <see cref="T:Rebus.Bus.NoTransaction"/> implementation of <see cref="T:Rebus.ITransactionContext"/> is always non-transactional
            </summary>
        </member>
        <member name="P:Rebus.Bus.NoTransaction.Item(System.String)">
            <summary>
            Gives access to a dictionary of stuff that will be kept for the duration of the transaction.
            </summary>
        </member>
        <member name="E:Rebus.Bus.NoTransaction.DoCommit">
            <summary>
            Event that is never raised because this implementation of <see cref="T:Rebus.ITransactionContext"/> is no transaction.
            Will throw an <see cref="T:System.InvalidOperationException"/> if someone subscribes
            </summary>
        </member>
        <member name="E:Rebus.Bus.NoTransaction.DoRollback">
            <summary>
            Event that is never raised because this implementation of <see cref="T:Rebus.ITransactionContext"/> is no transaction.
            Will throw an <see cref="T:System.InvalidOperationException"/> if someone subscribes
            </summary>
        </member>
        <member name="E:Rebus.Bus.NoTransaction.BeforeCommit">
            <summary>
            Event that is never raised because this implementation of <see cref="T:Rebus.ITransactionContext"/> is no transaction.
            Will throw an <see cref="T:System.InvalidOperationException"/> if someone subscribes
            </summary>
        </member>
        <member name="E:Rebus.Bus.NoTransaction.AfterRollback">
            <summary>
            Event that is never raised because this implementation of <see cref="T:Rebus.ITransactionContext"/> is no transaction.
            Will throw an <see cref="T:System.InvalidOperationException"/> if someone subscribes
            </summary>
        </member>
        <member name="E:Rebus.Bus.NoTransaction.Cleanup">
            <summary>
            Event that is raised when this transaction context is disposed
            </summary>
        </member>
        <member name="T:Rebus.Bus.QueueCommitException">
            <summary>
            Special exception that wraps an exception that occurred while committing the current queue transaction
            </summary>
        </member>
        <member name="M:Rebus.Bus.QueueCommitException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Mandatory exception ctor
            </summary>
        </member>
        <member name="M:Rebus.Bus.QueueCommitException.#ctor(System.Exception)">
            <summary>
            Constructs the queue commit exception with a message containint the exception that was caught when trying to
            commit the queue transaction
            </summary>
        </member>
        <member name="T:Rebus.IRebusBatchOperations">
            <summary>
            Groups the batch operations that Rebus can perform.
            </summary>
        </member>
        <member name="M:Rebus.IRebusBatchOperations.Send(System.Collections.IEnumerable)">
            <summary>
            Sends the specified batch of messages, dividing the batch into batches
            for individual recipients if necessary. For each recipient, the order
            of the messages within the batch is preserved.
            </summary>
        </member>
        <member name="M:Rebus.IRebusBatchOperations.Publish(System.Collections.IEnumerable)">
            <summary>
            Publishes the specified batch of messages, dividing the batch into
            batches for individual recipients if necessary. For each subscriber,
            the order of the messages within the batch is preserved.
            </summary>
        </member>
        <member name="M:Rebus.IRebusBatchOperations.Reply(System.Collections.IEnumerable)">
            <summary>
            Sends a batch of replies back to the sender of the message currently being handled.
            Can only be called when a <see cref="T:Rebus.MessageContext"/> has been established, which happens
            during the handling of an incoming message.
            </summary>
        </member>
        <member name="T:Rebus.IRebusEvents">
            <summary>
            Groups the different event hooks that Rebus exposes.
            </summary>
        </member>
        <member name="M:Rebus.IRebusEvents.AddUnitOfWorkManager(Rebus.Bus.IUnitOfWorkManager)">
            <summary>
            Adds a unit of work manager that will be allowed to create a unit of work for each incoming message
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.BusStarted">
            <summary>
            Event that will be raised immediately after bus is started
            and ready to handle messages
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.BusStopped">
            <summary>
            Event that will be raised when the bus is disposed
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.BeforeTransportMessage">
            <summary>
            Event that will be raised immediately after receiving a transport 
            message, before any other actions are executed.
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.AfterTransportMessage">
            <summary>
            Event that will be raised after a transport message has been handled.
            If an error occurs, the caught exception will be passed to the
            listeners. If no errors occur, the passed exception will be null.
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.PoisonMessage">
            <summary>
            Event that will be raised whenever it is determined that a message
            has failed too many times.
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.MessageSent">
            <summary>
            Event that will be raised immediately when the bus is used to send a logical message.
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.BeforeMessage">
            <summary>
            Event that will be raised for each received logical message (i.e. it will only be called
            if deserialization completed, and the transport message does in fact contain one or more
            logical messages).
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.AfterMessage">
            <summary>
            Event that will be raised for each received logical message (i.e. it will only be called
            if deserialization completed, and the transport message does in fact contain one or more
            logical messages).
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.UncorrelatedMessage">
            <summary>
            Event that is raised when an incoming message can be handled by a saga handler, but it
            turns out that no saga data instance could be correlated with the message.
            </summary>
        </member>
        <member name="E:Rebus.IRebusEvents.MessageContextEstablished">
            <summary>
            Event that is raised when an incoming transport message has been properly deserialized,
            and it is about to be dispatched. The message context will last for the duration of the
            message processing and is disposed at the very end.
            </summary>
        </member>
        <member name="P:Rebus.IRebusEvents.MessageMutators">
            <summary>
            Contains a pipeline of message mutators that will be run in order when messages are sent,
            and in reverse order when messages are received.
            </summary>
        </member>
        <member name="T:Rebus.Bus.RebusRouting">
            <summary>
            Implements the explicitly routed messages API by using your ordinary <see cref="T:Rebus.Bus.RebusBus"/>
            </summary>
        </member>
        <member name="T:Rebus.IRebusRouting">
            <summary>
            Groups Rebus' operations for manually routing messages.
            </summary>
        </member>
        <member name="M:Rebus.IRebusRouting.Send``1(System.String,``0)">
            <summary>
            Sends the specified message to the specified destination.
            </summary>
        </member>
        <member name="M:Rebus.IRebusRouting.Subscribe``1(System.String)">
            <summary>
            Sends a subscription request for <typeparamref name="TEvent"/> to the specified 
            destination.
            </summary>
        </member>
        <member name="M:Rebus.IRebusRouting.Unsubscribe``1(System.String)">
            <summary>
            Sends an unsubscription request for <typeparamref name="TEvent"/> to the specified 
            destination
            </summary>
        </member>
        <member name="M:Rebus.IRebusRouting.Subscribe(System.Type)">
            <summary>
            Sends a subscription request for the specified event type to the destination as
            specified by the currently used implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/>.
            </summary>
        </member>
        <member name="M:Rebus.IRebusRouting.Subscribe(System.Type,System.String)">
            <summary>
            Sends a subscription request for the specified event type to the specified destination
            </summary>
        </member>
        <member name="M:Rebus.IRebusRouting.Unsubscribe(System.Type)">
            <summary>
            Sends an unsubscription request for the specified event type to the destination as
            specified by the currently used implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/>.
            </summary>
        </member>
        <member name="M:Rebus.IRebusRouting.Unsubscribe(System.Type,System.String)">
            <summary>
            Sends an unsubscription request for the specified event type to the specified destination
            </summary>
        </member>
        <member name="M:Rebus.IRebusRouting.ForwardCurrentMessage(System.String)">
            <summary>
            Sends the message currently being handled to the specified endpoint, preserving all
            of the transport level headers.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusRouting.#ctor(Rebus.Bus.RebusBus)">
            <summary>
            Constructs the routing API with the specified <see cref="T:Rebus.Bus.RebusBus"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusRouting.Send``1(System.String,``0)">
            <summary>
            Sends the specified message to the specified destination.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusRouting.Subscribe``1(System.String)">
            <summary>
            Sends a subscription request for <typeparamref name="TEvent"/> to the specified 
            destination.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusRouting.Unsubscribe``1(System.String)">
            <summary>
            Sends an unsubscription request for <typeparamref name="TEvent"/> to the specified 
            destination
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusRouting.Subscribe(System.Type)">
            <summary>
            Sends a subscription request for the specified event type to the destination as
            specified by the currently used implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/>.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusRouting.Subscribe(System.Type,System.String)">
            <summary>
            Sends a subscription request for the specified event type to the specified destination
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusRouting.Unsubscribe(System.Type)">
            <summary>
            Sends an unsubscription request for the specified event type to the destination as
            specified by the currently used implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/>.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusRouting.Unsubscribe(System.Type,System.String)">
            <summary>
            Sends an unsubscription request for the specified event type to the specified destination
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusRouting.ForwardCurrentMessage(System.String)">
            <summary>
            Sends the message currently being handled to the specified endpoint, preserving all
            of the transport level headers.
            </summary>
        </member>
        <member name="T:Rebus.IHandleMessages`1">
            <summary>
            This is the main message handler interface of Rebus. Implement these to be
            called when messages are dispatched.
            </summary>
            <typeparam name="TMessage">The type of the message being handled. Can be any assignable type as well.</typeparam>
        </member>
        <member name="T:Rebus.IHandleMessages">
            <summary>
            Top level handler interface that allows for interacting with handlers in
            a message type-agnostic manner.
            </summary>
        </member>
        <member name="M:Rebus.IHandleMessages`1.Handle(`0)">
            <summary>
            Handler method that will be called by the dispatcher for each logical message contained in the received transport message
            </summary>
        </member>
        <member name="T:Rebus.Bus.TransactionContext">
            <summary>
            Gives access to a thread-bound <see cref="T:Rebus.ITransactionContext"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.TransactionContext.Set(Rebus.ITransactionContext)">
            <summary>
            Assigns the specified <see cref="T:Rebus.ITransactionContext"/> to the current context
            </summary>
        </member>
        <member name="M:Rebus.Bus.TransactionContext.Clear">
            <summary>
            Clears any context that might currently be assigned
            </summary>
        </member>
        <member name="P:Rebus.Bus.TransactionContext.Current">
            <summary>
            Gets the <see cref="T:Rebus.ITransactionContext"/> associated with the current thread
            </summary>
        </member>
        <member name="T:Rebus.Bus.TxBomkarl">
            <summary>
            Special implementation of <see cref="T:Rebus.ITransactionContext"/> that is designed to work with message handlers
            </summary>
        </member>
        <member name="M:Rebus.Bus.TxBomkarl.#ctor">
            <summary>
            Constructs the context and sets itself as current in <see cref="T:Rebus.Bus.TransactionContext"/>.
            </summary>
        </member>
        <member name="P:Rebus.Bus.TxBomkarl.Item(System.String)">
            <summary>
            Gives access to a dictionary of stuff that will be kept for the duration of the transaction.
            </summary>
        </member>
        <member name="T:Rebus.Bus.UnitOfWorkCommitException">
            <summary>
            Special exception that wraps an exception that occurred while committing the current unit of work
            </summary>
        </member>
        <member name="M:Rebus.Bus.UnitOfWorkCommitException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Mandatory exception ctor
            </summary>
        </member>
        <member name="M:Rebus.Bus.UnitOfWorkCommitException.#ctor(System.Exception,Rebus.Bus.IUnitOfWork)">
            <summary>
            Constructs the unit of work commit exception with a message pointing to the unit of work that could not be committed,
            wrapping as the inner exception the exception caught on commit
            </summary>
        </member>
        <member name="T:Rebus.Configuration.BackoffBehavior">
            <summary>
            Defines the worker thread back off behavior.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BackoffBehavior.Default">
            <summary>
            Returns the default backoff behavior, which is a compromise between low latency and not thrashing the queueing system too hard.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BackoffBehavior.LowLatency">
            <summary>
            Returns a backoff behavior, that will only wait a short while between re-polling the queueing system, which may lead to
            putting slightly more load on the queueing system.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BackoffBehavior.Add(System.TimeSpan)">
            <summary>
            Adds the given backoff interval to the collection of backoff times
            </summary>
        </member>
        <member name="T:Rebus.Configuration.BaseConfigurer">
            <summary>
            Base class of all configurers. Defines what a configurer has access to, and might provide some
            conveniene methods to do common configuration stuff.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BaseConfigurer.#ctor(Rebus.Configuration.ConfigurationBackbone)">
            <summary>
            Uses the specified <see cref="T:Rebus.Configuration.ConfigurationBackbone"/> to store references to implementations of all Rebus' abstractions
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BaseConfigurer.AddDecoration(System.Action{Rebus.Configuration.ConfigurationBackbone})">
            <summary>
            Adds the specified function as a decoration step which will be executed when it's time to instantiate <see cref="T:Rebus.Bus.RebusBus"/>
            </summary>
        </member>
        <member name="P:Rebus.Configuration.BaseConfigurer.Backbone">
            <summary>
            Accesses the backbone that this configurer is currently applying its configurations to
            </summary>
        </member>
        <member name="T:Rebus.Configuration.BuiltinContainerAdapter">
            <summary>
            Very simple and independent container adapter that relies on <see cref="T:Rebus.SimpleHandlerActivator"/>
            to activate handlers.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.IContainerAdapter">
            <summary>
            Extends <see cref="T:Rebus.IActivateHandlers"/> into a container adapter,
            which has the capability of storing the created bus instance(s)
            and disposing it/them at the right time - usually when the application
            ends (i.e. when the underlying IoC container is disposed).
            </summary>
        </member>
        <member name="T:Rebus.IActivateHandlers">
            <summary>
            Implement this in order to delegate the instantiation work to your
            IoC container. Seriously, do it.
            </summary>
        </member>
        <member name="M:Rebus.IActivateHandlers.GetHandlerInstancesFor``1">
            <summary>
            Should get a sequence of handlers where each handler implements
            the <see cref="T:Rebus.IHandleMessages`1"/> interface.
            </summary>
        </member>
        <member name="M:Rebus.IActivateHandlers.Release(System.Collections.IEnumerable)">
            <summary>
            Is called after each handler has been invoked. Please note that this method
            will be called for all handlers - i.e. if you add more handlers to the pipeline
            in the Filter method of <see cref="T:Rebus.IInspectHandlerPipeline"/>, this method will
            be called for those additional handlers as well. This, in turn, allows you to
            implement <see cref="T:Rebus.IInspectHandlerPipeline"/>, supplying your implementation
            of <see cref="T:Rebus.IActivateHandlers"/> to that implementation, allowing any manually
            pulled handler instances to be released in the right way.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.IContainerAdapter.SaveBusInstances(Rebus.IBus)">
            <summary>
            Instructs the container to save the specified bus instance 
            and take responsibility of their disposal when it's the right time.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BuiltinContainerAdapter.Register(System.Type)">
            <summary>
            Registers the given handler type. It is assumed that the type registered has a public
            default constructor - otherwise, instantiation will fail.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BuiltinContainerAdapter.Register``1(System.Func{``0})">
            <summary>
            Registers a factory method that is capable of creating a handler instance.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BuiltinContainerAdapter.Handle``1(System.Action{``0})">
            <summary>
            Registers a function that can handle messages of the specified type.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BuiltinContainerAdapter.GetHandlerInstancesFor``1">
            <summary>
            Uses the underlying <see cref="T:Rebus.SimpleHandlerActivator"/> to look up handler instances
            that can handle messages of type <typeparamref name="T"/>
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BuiltinContainerAdapter.Release(System.Collections.IEnumerable)">
            <summary>
            Uses the underlying <see cref="T:Rebus.SimpleHandlerActivator"/> to release the given handler instances
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BuiltinContainerAdapter.SaveBusInstances(Rebus.IBus)">
            <summary>
            Saves the given <see cref="T:Rebus.IBus"/> reference for later use
            </summary>
        </member>
        <member name="M:Rebus.Configuration.BuiltinContainerAdapter.Dispose">
            <summary>
            Makes sure that the referenced <see cref="T:Rebus.IBus"/> is disposed
            </summary>
        </member>
        <member name="P:Rebus.Configuration.BuiltinContainerAdapter.Bus">
            <summary>
            Use this property to access the bus instance
            </summary>
        </member>
        <member name="T:Rebus.Configuration.ConfigurationBackbone">
            <summary>
            The backbone holds configured instances of Rebus' abstractions
            </summary>
        </member>
        <member name="M:Rebus.Configuration.ConfigurationBackbone.#ctor(Rebus.Configuration.IContainerAdapter)">
            <summary>
            Creates the backbone and installs the specified <see cref="T:Rebus.Configuration.IContainerAdapter"/> as the
            current implementation of <see cref="T:Rebus.IActivateHandlers"/>.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.ConfigurationBackbone.LoadFromRegistry``1(System.Func{``0})">
            <summary>
            Attempts to load from the registry the instance stored with the given type key.
            If no instance is found, the given factory method is invoked, whereafter the
            returned object is stored under the key. This mechanism allows different configurers
            to cooperate and possibly configure the same instances, even though an instance might
            be sitting somewhere as a decorator.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.ConfigurationBackbone.ConfigureEvents(System.Action{Rebus.IRebusEvents})">
            <summary>
            Configures events
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigurationBackbone.SendMessages">
            <summary>
            Determines how Rebus will send messages
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigurationBackbone.ReceiveMessages">
            <summary>
            Determines how Rebus will receive messages
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigurationBackbone.ActivateHandlers">
            <summary>
            Determines how Rebus will get handler instances when an incoming message needs to be dispatched
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigurationBackbone.SerializeMessages">
            <summary>
            Determines how Rebus serializes messages
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigurationBackbone.ErrorTracker">
            <summary>
            Determines how Rebus tracks IDs of failed deliveries between retries
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigurationBackbone.DetermineMessageOwnership">
            <summary>
            Determines how Rebus finds out which endpoint owns any given message type
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigurationBackbone.StoreSubscriptions">
            <summary>
            Determines how Rebus stores subscribers
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigurationBackbone.StoreSagaData">
            <summary>
            Determines how Rebus makes saga data persistent
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigurationBackbone.InspectHandlerPipeline">
            <summary>
            Determines how Rebus may filter the handler pipeline before the handlers are executed
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigurationBackbone.StoreTimeouts">
            <summary>
            Determines how Rebus persists timeouts
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigurationBackbone.AdditionalBehavior">
            <summary>
            Configures additional behavioral elements
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigurationBackbone.LoggerFactory">
            <summary>
            Determines how Rebus and Rebus components do their logging
            </summary>
        </member>
        <member name="T:Rebus.Configuration.Configure">
            <summary>
            Main configuration API entry point. Just go ahead and
            <code>
            using(var adapter = new BuiltinContainerAdapter())
            {
                Configure.With(adapter)
                    .Transport(t => t.UseMsmqAndGetInputQueueNameFromAppConfig())
                    .determineMessageOwnership(d => d.FromRebusConfigurationSection())
                    .CreateBus()
                    .Start();
            
                adapter.Bus.Send(new SomeMessage{Text = "hola mundo!"});
            }
            </code>
            </summary>
        </member>
        <member name="M:Rebus.Configuration.Configure.With(Rebus.Configuration.IContainerAdapter)">
            <summary>
            Starts configuring Rebus with the specified container adapter.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.DecoratorsConfigurer">
            <summary>
            Configurer that allows for decorators to be added in the form of "decoration steps"
            </summary>
        </member>
        <member name="T:Rebus.Configuration.ConfigureAdditionalBehavior">
            <summary>
            Contains additional behavioral stuff that affects how Rebus does its work
            </summary>
        </member>
        <member name="M:Rebus.Configuration.ConfigureAdditionalBehavior.#ctor">
            <summary>
            Creates an instance of this behavior thingie with all the defaults set
            </summary>
        </member>
        <member name="M:Rebus.Configuration.ConfigureAdditionalBehavior.EnterOneWayClientMode">
            <summary>
            Make entering one-way client mode a one-way operation - everything about this is SO one-way!
            (because, otherwise the <see cref="T:Rebus.Transports.OneWayClientGag"/> might have been installed and hidden
            beneath a couple of decorators, and in since the gag makes Barbara Liskov sad, we need to
            avoid certain operations for the entire lifetime of the bus)
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigureAdditionalBehavior.HandleMessagesInTransactionScope">
            <summary>
            Configures whether Rebus should create a transaction scope around the handling of transport messages.
            Defaults to false.
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigureAdditionalBehavior.BackoffBehavior">
            <summary>
            When a worker attempts to receive a message, and no message is available, the times specified in the
            given backoff behavior will be used to cut the queueing system some slack.
            </summary>
        </member>
        <member name="P:Rebus.Configuration.ConfigureAdditionalBehavior.OneWayClientMode">
            <summary>
            Indicates whether the bus is in one-way client mode - i.e. if it can be used only for outgoing
            messages.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.JsonSerializationOptions">
            <summary>
            Allows for configuring details around how JSON serialization should work
            </summary>
        </member>
        <member name="M:Rebus.Configuration.JsonSerializationOptions.AddNameResolver(System.Func{System.Type,Rebus.Serialization.Json.TypeDescriptor})">
            <summary>
            Adds a function that will determine how a given type is turned into a <see cref="T:Rebus.Serialization.Json.TypeDescriptor"/>.
            Return null if the function has no opinion about this particular type, allowing other functions and
            ultimately the default JSON serializer's opinion to be used.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.JsonSerializationOptions.AddTypeResolver(System.Func{Rebus.Serialization.Json.TypeDescriptor,System.Type})">
            <summary>
            Adds a function that will determine how a given <see cref="T:Rebus.Serialization.Json.TypeDescriptor"/> is turned into a .NET type.
            Return null if the function has no opinion about this particular type descriptor, allowing other functions and
            ultimately the default JSON serializer's opinion to be used.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.JsonSerializationOptions.SpecifyEncoding(System.Text.Encoding)">
            <summary>
            Overrides the default UTF-7 encoding and uses the specified encoding instead when serializing. The used encoding
            is put in a header, so you don't necessarily need to specify the same encoding in order to be able to deserialize
            properly.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.JsonSerializationOptions.SerializeEnumAsStrings(System.Boolean)">
            <summary>
            Configure the serializer to serialize the enums as string.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RebusBehaviorConfigurer">
            <summary>
            Configurer that configures various behavioral aspects of Rebus
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusBehaviorConfigurer.SetMaxRetriesFor``1(System.Int32)">
            <summary>
            Customizes the max number of retries for exceptions of this type. Note that the order of calls will determine
            the priority of the customizations, and customizations of base classes will affect derivations as well.
            E.g. if you start out by setting max retries for <see cref="T:System.Exception"/> to 5 and subsequently set max retries
            for <see cref="T:System.ApplicationException"/> to 200, all exceptions will result in 5 retries because all exceptions
            are derived from <see cref="T:System.Exception"/>.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusBehaviorConfigurer.HandleMessagesInsideTransactionScope">
            <summary>
            Configures Rebus to automatically create a <see cref="T:System.Transactions.TransactionScope"/> around the handling of transport messages,
            allowing client code to enlist and be properly committed when the scope is completed. Please not that this is NOT
            a requirement in order to have transactional handling of messages since the queue transaction surrounds the client
            code entirely and will be committed/rolled back depending on whether the client code throws.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusBehaviorConfigurer.SetCurrentPrincipalWhenUserNameHeaderIsPresent">
            <summary>
            Configures Rebus to establish an <see cref="T:System.Security.Principal.IPrincipal"/> and set it on <see cref="P:System.Threading.Thread.CurrentPrincipal"/>
            if the special <see cref="F:Rebus.Shared.Headers.UserName"/> header is present. It will only be set if the user name header
            is present and if the value does in fact contain something.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusBehaviorConfigurer.SetLowLatencyBackoffBehavior">
            <summary>
            Sets the backoff behavior to the low latency behavior. This lets Rebus check the message queue every 20ms
            for new messages. Do note, this increases the load on the message queue.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RebusTimeoutsConfigurer">
            <summary>
            Configurer to configure how Rebus handles messages deferred to the future. Will decide which
            implementation of <see cref="T:Rebus.Timeout.IStoreTimeouts"/> that goes into Rebus, which ultimately decides
            whether <see cref="T:Rebus.Messages.TimeoutRequest"/>s are sent locally or to an external timeout manager
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusTimeoutsConfigurer.UseExternalTimeoutManager">
            <summary>
            Configures Rebus to store timeouts externally
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusTimeoutsConfigurer.StoreInSqlServer(System.String,System.String)">
            <summary>
            Configures Rebus to store timeouts in SQL server
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusTimeoutsConfigurer.StoreInMemory">
            <summary>
            Configures Rebus to store timeouts internally in memory. This option should probably not be used for production scenarios, because
            timeouts will not survive a restart.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusTimeoutsConfigurer.Use(Rebus.Timeout.IStoreTimeouts)">
            <summary>
            Installs the given implementation of <see cref="T:Rebus.Timeout.IStoreTimeouts"/>
            </summary>
        </member>
        <member name="T:Rebus.Configuration.SqlServerSagaPersisterFluentConfigurer">
            <summary>
            Fluent configurer that allows for configuring the underlying <see cref="T:Rebus.Persistence.SqlServer.SqlServerSagaPersister"/>
            </summary>
        </member>
        <member name="M:Rebus.Configuration.SqlServerSagaPersisterFluentConfigurer.EnsureTablesAreCreated">
            <summary>
            Checks to see if the underlying SQL tables are created - if none of them exist,
            they will automatically be created
            </summary>
        </member>
        <member name="M:Rebus.Configuration.SqlServerSagaPersisterFluentConfigurer.DoNotIndexNullProperties">
            <summary>
            Configures the persister to ignore null-valued correlation properties and not add them to the saga index.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.SqlServerSubscriptionStorageFluentConfigurer">
            <summary>
            Fluent configurer that allows for configuring the underlying <see cref="T:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Configuration.SqlServerSubscriptionStorageFluentConfigurer.EnsureTableIsCreated">
            <summary>
            Checks to see if the database contains the configured subscriptions table, and if that is not
            the case it will be created
            </summary>
        </member>
        <member name="T:Rebus.Configuration.SqlServerTimeoutStorageFluentConfigurer">
            <summary>
            Fluent configurer that allows for further configuration of the installed <see cref="T:Rebus.Persistence.SqlServer.SqlServerTimeoutStorage"/>
            </summary>
        </member>
        <member name="M:Rebus.Configuration.SqlServerTimeoutStorageFluentConfigurer.EnsureTableIsCreated">
            <summary>
            Checks to see if a table exists with the configured name - if that is not the case, it will be created.
            If a table already exists, nothing happens.
            </summary>
        </member>
        <member name="T:Rebus.ExceptionExtensions">
            <summary>
            Extensions useful for doing special stuff on exceptions.
            </summary>
        </member>
        <member name="M:Rebus.ExceptionExtensions.PreserveStackTrace(System.Exception)">
            <summary>
            Modifies the specified exception's _remoteStackTraceString. I have no idea how this works, but it allows 
            for unpacking a re-throwable inner exception from a caught <see cref="T:System.Reflection.TargetInvocationException"/>.
            Read <see cref="!:http://stackoverflow.com/a/2085364/6560"/> for more information.
            </summary>
        </member>
        <member name="T:Rebus.MessageHandleException">
            <summary>
            Special exception that wraps an exception that occurred while handling a message
            </summary>
        </member>
        <member name="M:Rebus.MessageHandleException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Mandatory exception ctor
            </summary>
        </member>
        <member name="M:Rebus.MessageHandleException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs the exception for the given message ID and exception that was caught while handling that message
            </summary>
        </member>
        <member name="P:Rebus.MessageHandleException.MessageId">
            <summary>
            Gets the ID of the message that could not be handled
            </summary>
        </member>
        <member name="T:Rebus.IMutateMessages">
            <summary>
            Implement this in order to get a hook that gets to mutate incoming and outgoing messages.
            </summary>
        </member>
        <member name="M:Rebus.IMutateMessages.MutateIncoming(System.Object)">
            <summary>
            Will be called once for each incoming logical message before it gets dispatched to handlers.
            </summary>
        </member>
        <member name="M:Rebus.IMutateMessages.MutateOutgoing(System.Object)">
            <summary>
            Will be called once for each outgoing logical message before it gets added to the outgoing
            transport message.
            </summary>
        </member>
        <member name="T:Rebus.INeedInitializationBeforeStart">
            <summary>
            Services injected into <see cref="T:Rebus.Bus.RebusBus"/> may implement this in order to be initialized right before the bus is started
            </summary>
        </member>
        <member name="M:Rebus.INeedInitializationBeforeStart.Initialize">
            <summary>
            Allows the implementor to perform some kind of initialization
            </summary>
        </member>
        <member name="T:Rebus.Logging.GhettoFileLoggerFactory">
            <summary>
            Crude file logger implementation
            </summary>
        </member>
        <member name="T:Rebus.Logging.AbstractRebusLoggerFactory">
            <summary>
            If you intend to implement your own logging, you probably want to derive
            from this class and implement <seealso cref="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger(System.Type)"/>.
            </summary>
        </member>
        <member name="T:Rebus.Logging.IRebusLoggerFactory">
            <summary>
            Basic interface of a Rebus logger factory. If you intend to implement your own,
            <see cref="T:Rebus.Logging.AbstractRebusLoggerFactory"/> is the one to derive from - you should
            probably not implement this interface directly.
            </summary>
        </member>
        <member name="M:Rebus.Logging.IRebusLoggerFactory.GetCurrentClassLogger">
            <summary>
            Gets a logger that is initialized to somehow carry information on the class that is using it.
            Be warned that this method will most likely be pretty slow, because it will probably rely on
            some clunky <see cref="T:System.Diagnostics.StackFrame"/> inspection.
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.GetLogger(System.Type)">
            <summary>
            Should get a logger for the specified type 
            </summary>
        </member>
        <member name="M:Rebus.Logging.AbstractRebusLoggerFactory.GetCurrentClassLogger">
            <summary>
            Gets a logger that is initialized to somehow carry information on the class that is using it.
            Be warned that this method will most likely be pretty slow, because it will probably rely on
            some clunky <see cref="T:System.Diagnostics.StackFrame"/> inspection.
            </summary>
        </member>
        <member name="M:Rebus.Logging.GhettoFileLoggerFactory.#ctor(System.String)">
            <summary>
            Creates a crude file-logging thingie, that will flush to the specified file every 500 ms
            </summary>
        </member>
        <member name="M:Rebus.Logging.GhettoFileLoggerFactory.WithFilter(System.Func{Rebus.Logging.GhettoFileLoggerFactory.LogMessage,System.Boolean})">
            <summary>
            Adds the specified filter predicate function to the list of filters that will be evaluated for each log message,
            determining whether or not the given message will end up in the file
            </summary>
        </member>
        <member name="M:Rebus.Logging.GhettoFileLoggerFactory.Finalize">
            <summary>
            Ensure, in the most hackish way possible, that the buffer is flushed to disk and that the background flush timer is stopped
            </summary>
        </member>
        <member name="M:Rebus.Logging.GhettoFileLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets a <see cref="T:Rebus.Logging.GhettoFileLoggerFactory.CrudeFileLogger"/> to log yo stuff good
            </summary>
        </member>
        <member name="T:Rebus.Logging.GhettoFileLoggerFactory.LogMessage">
            <summary>
            Model of a log message that has been queued to be flushed to disk later
            </summary>
        </member>
        <member name="P:Rebus.Logging.GhettoFileLoggerFactory.LogMessage.LoggerType">
            <summary>
            Indicates the type from which the logger that created the log message was created
            </summary>
        </member>
        <member name="P:Rebus.Logging.GhettoFileLoggerFactory.LogMessage.Time">
            <summary>
            The time when this log message was emitted
            </summary>
        </member>
        <member name="P:Rebus.Logging.GhettoFileLoggerFactory.LogMessage.Message">
            <summary>
            The log message
            </summary>
        </member>
        <member name="P:Rebus.Logging.GhettoFileLoggerFactory.LogMessage.Level">
            <summary>
            The log level
            </summary>
        </member>
        <member name="T:Rebus.Logging.ILog">
            <summary>
            Interface of a Rebus logger
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Debug(System.String,System.Object[])">
            <summary>
            Writes the specified message with the DEBUG level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Info(System.String,System.Object[])">
            <summary>
            Writes the specified message with the INFO level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Warn(System.String,System.Object[])">
            <summary>
            Writes the specified message with the WARN level
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Error(System.Exception,System.String,System.Object[])">
            <summary>
            Writes the specified message with the ERROR level and includes the full details of the specified exception
            </summary>
        </member>
        <member name="M:Rebus.Logging.ILog.Error(System.String,System.Object[])">
            <summary>
            Writes the specified message with the ERROR level
            </summary>
        </member>
        <member name="T:Rebus.MultipleSagaHandlersFoundException">
            <summary>
            Exception that is thrown when an incoming message can be handled by multiple saga handlers.
            This is an error because it would require that multiple saga data instances could be updated
            atomically by all saga persisters.
            </summary>
        </member>
        <member name="M:Rebus.MultipleSagaHandlersFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Mandatory exception ctor
            </summary>
        </member>
        <member name="M:Rebus.MultipleSagaHandlersFoundException.#ctor(System.Object,System.Type[])">
            <summary>
            Constructs the exception with a reference to the message that could be handled by multiple saga handlers
            </summary>
        </member>
        <member name="P:Rebus.MultipleSagaHandlersFoundException.SagaHandlerTypes">
            <summary>
            Gets the types of saga handlers that were found
            </summary>
        </member>
        <member name="P:Rebus.MultipleSagaHandlersFoundException.MessageThatCouldBeHandledByMultipleSagaHandlers">
            <summary>
            Gets the message that resulted in multiple saga handlers being resolved
            </summary>
        </member>
        <member name="T:Rebus.Persistence.HybridSagaPersister">
            <summary>
            Experimental saga persister that is capable of using different saga persisters depending on the type of saga data.
            </summary>
        </member>
        <member name="T:Rebus.IStoreSagaData">
            <summary>
            Implement this in order to control how saga data gets persisted.
            </summary>
        </member>
        <member name="M:Rebus.IStoreSagaData.Insert(Rebus.ISagaData,System.String[])">
            <summary>
            Inserts the specified saga data, ensuring that the specified fields can be used
            to correlate with incoming messages. If a saga already exists with the specified
            ID and/or correlations, an <see cref="T:Rebus.OptimisticLockingException"/> must be thrown.
            </summary>
        </member>
        <member name="M:Rebus.IStoreSagaData.Update(Rebus.ISagaData,System.String[])">
            <summary>
            Updates the specified saga data in the underlying data store, ensuring that the
            specified fields can be used to correlate with incoming messages. If the saga no
            longer exists, or if the revision does not correspond to the expected revision number,
            and <see cref="T:Rebus.OptimisticLockingException"/> must be thrown.
            </summary>
        </member>
        <member name="M:Rebus.IStoreSagaData.Delete(Rebus.ISagaData)">
            <summary>
            Deletes the specified saga data from the underlying data store.
            </summary>
            <param name="sagaData"></param>
        </member>
        <member name="M:Rebus.IStoreSagaData.Find``1(System.String,System.Object)">
            <summary>
            Queries the underlying data store for the saga whose correlation field has a value
            that matches the given field from the incoming message.
            </summary>
        </member>
        <member name="F:Rebus.Persistence.HybridSagaPersister.fallbackSagaPersister">
            <summary>
            Stores the fallback saga persister which will be used for all kinds of saga data when a custom persister has not been configured
            </summary>
        </member>
        <member name="F:Rebus.Persistence.HybridSagaPersister.availableCustomSagaPersisters">
            <summary>
            Contains a list of available persister instances. To actually use one of these, <see cref="M:Rebus.Persistence.HybridSagaPersister.Customize``2"/> must
            be called in order to map a specific saga data type to a persister type.
            </summary>
        </member>
        <member name="F:Rebus.Persistence.HybridSagaPersister.customSagaPersisters">
            <summary>
            Contains the actual (sagaDataType) => (persisterInstance) mapping.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.HybridSagaPersister.#ctor(Rebus.IStoreSagaData)">
            <summary>
            Constructs the hybrid saga persister and configures the fallback saga persister, which will be used in all cases
            where a custom saga persister has not been supplied.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.HybridSagaPersister.Insert(Rebus.ISagaData,System.String[])">
            <summary>
            Inserts the specified saga data, ensuring that the specified fields can be used to correlate with incoming messages. If a saga already exists with the specified
            ID and/or correlations, an <see cref="T:Rebus.OptimisticLockingException"/> must be thrown. If configured, a custom saga persister will be used to actually carry out the operation,
            otherwise the fallback saga persister will be used.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.HybridSagaPersister.Update(Rebus.ISagaData,System.String[])">
            <summary>
            Updates the specified saga data in the underlying data store, ensuring that the specified fields can be used to correlate with incoming messages. If the saga no
            longer exists, or if the revision does not correspond to the expected revision number, and <see cref="T:Rebus.OptimisticLockingException"/> must be thrown. If configured, 
            a custom saga persister will be used to actually carry out the operation, otherwise the fallback saga persister will be used.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.HybridSagaPersister.Delete(Rebus.ISagaData)">
            <summary>
            Deletes the specified saga data from the underlying data store. If configured, a custom saga persister will be used to actually carry out the operation,
            otherwise the fallback saga persister will be used.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.HybridSagaPersister.Find``1(System.String,System.Object)">
            <summary>
            Queries the underlying data store for the saga whose correlation field has a value that matches the given field from the incoming message.
            If configured, a custom saga persister will be used to actually carry out the operation, otherwise the fallback saga persister will be used.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.HybridSagaPersister.Add(Rebus.IStoreSagaData)">
            <summary>
            Adds the specified saga persister to the list of available saga persisters. At most one persister of each type may be added this way.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.HybridSagaPersister.Customize``2">
            <summary>
            Specifies for the given <typeparamref name="TSagaData"/> type that the persister of type <typeparamref name="TSagaPersister"/> must be used.
            An instance of <typeparamref name="TSagaPersister"/> must be available at this point, so it must be added by calling <see cref="M:Rebus.Persistence.HybridSagaPersister.Add(Rebus.IStoreSagaData)"/> before
            calling this method.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.HybridSagaPersister.Customize``1(Rebus.IStoreSagaData)">
            <summary>
            Specifies for the given <typeparamref name="TSagaData"/> type that the given saga persister instance must be used.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerStorage">
            <summary>
            Base class for MS SQL Server storage implementations
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerStorage.CreateConnection(System.String)">
            <summary>
            Create connection at handle set transaction if necessary
            </summary>
            <param name="connectionString"></param>
            <returns></returns>
        </member>
        <member name="T:Rebus.SagaContext">
            <summary>
            Represents the fact that we're currently handling a message that was correctly correlated with
            a saga instance - thus it makes sense to say that we're in a saga context
            </summary>
        </member>
        <member name="F:Rebus.SagaContext.SagaContextItemKey">
            <summary>
            The message context itemss key under which this saga context will register itself
            </summary>
        </member>
        <member name="M:Rebus.SagaContext.#ctor(System.Guid)">
            <summary>
            Constructs the saga context, registering the context under the key
            <see cref="F:Rebus.SagaContext.SagaContextItemKey"/> in the current message context
            (if one is available)
            </summary>
        </member>
        <member name="M:Rebus.SagaContext.Dispose">
            <summary>
            Makes sure that the saga context is removed from the items dictionary of the current <see cref="T:Rebus.MessageContext"/>
            </summary>
        </member>
        <member name="P:Rebus.SagaContext.Id">
            <summary>
            Gets the ID of the saga data whose context we're currently in
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Json.TypeDescriptor">
            <summary>
            Description of a .NET type that includes the name of an assembly
            and a fully qualified type name
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.TypeDescriptor.#ctor(System.String,System.String)">
            <summary>
            Constructs the type desciptor
            </summary>
        </member>
        <member name="P:Rebus.Serialization.Json.TypeDescriptor.AssemblyName">
            <summary>
            Gets the assembly name
            </summary>
        </member>
        <member name="P:Rebus.Serialization.Json.TypeDescriptor.TypeName">
            <summary>
            Gets the fully qualified type name
            </summary>
        </member>
        <member name="T:Rebus.Testing.FakeBus">
            <summary>
            Implementation of <see cref="T:Rebus.IBus"/> that is meant to be used in tests. Collects
            all sent messages and headers etc., allowing tests to inspect them during the
            assert phase of the test.
            </summary>
        </member>
        <member name="T:Rebus.IBus">
            <summary>
            This is the main API of Rebus. Most application code should not depend on
            any other operation of <see cref="T:Rebus.Bus.RebusBus"/>.
            </summary>
        </member>
        <member name="M:Rebus.IBus.Send``1(``0)">
            <summary>
            Sends the specified message to the destination as specified by the currently
            used implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/>.
            </summary>
        </member>
        <member name="M:Rebus.IBus.SendLocal``1(``0)">
            <summary>
            Sends the specified message to the bus' own input queue.
            </summary>
        </member>
        <member name="M:Rebus.IBus.Reply``1(``0)">
            <summary>
            Sends a reply back to the sender of the message currently being handled. Can only
            be called when a <see cref="T:Rebus.MessageContext"/> has been established, which happens
            during the handling of an incoming message.
            </summary>
        </member>
        <member name="M:Rebus.IBus.Subscribe``1">
            <summary>
            Sends a subscription request for <typeparamref name="TEvent"/> to the destination as
            specified by the currently used implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/>.
            </summary>
        </member>
        <member name="M:Rebus.IBus.Unsubscribe``1">
            <summary>
            Sends an unsubscription request for <typeparamref name="TEvent"/> to the destination as
            specified by the currently used implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/>.
            </summary>
        </member>
        <member name="M:Rebus.IBus.Publish``1(``0)">
            <summary>
            Publishes the specified event message to all endpoints that are currently subscribed.
            The publisher should have some kind of <see cref="T:Rebus.IStoreSubscriptions"/> implementation,
            preferably a durable implementation like e.g. <see cref="T:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage"/>.
            </summary>
        </member>
        <member name="M:Rebus.IBus.Defer(System.TimeSpan,System.Object)">
            <summary>
            Sends the message to the timeout manager, which will send it back after the specified
            time span has elapsed. Note that you must have a running timeout manager for this to
            work.
            </summary>
        </member>
        <member name="M:Rebus.IBus.AttachHeader(System.Object,System.String,System.String)">
            <summary>
            Attaches to the specified message a header with the given key and value. The header will
            be associated with the message, and will be supplied when the message is sent - even if
            it is sent multiple times.
            </summary>
        </member>
        <member name="P:Rebus.IBus.Advanced">
            <summary>
            Gain access to more advanced and less commonly used features of the bus
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Send``1(``0)">
            <summary>
            Stores the message in the list of implicitly routed sent messages: <see cref="P:Rebus.Testing.FakeBus.SentMessages"/>
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.SendLocal``1(``0)">
            <summary>
            Stores the message in the list of message explicitly sent to self: <see cref="P:Rebus.Testing.FakeBus.LocallySentMessages"/>
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Reply``1(``0)">
            <summary>
            Stores the message in the list of sent replies: <see cref="P:Rebus.Testing.FakeBus.Replies"/>
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Subscribe``1">
            <summary>
            Stores the event type in the list of implicitly routed subscribed types: <see cref="P:Rebus.Testing.FakeBus.Subscriptions"/>
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Unsubscribe``1">
            <summary>
            Stores the event type in the list of implicitly routed unsubscribed types: <see cref="P:Rebus.Testing.FakeBus.Unsubscriptions"/>
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Publish``1(``0)">
            <summary>
            Stores the message in the list of published events: <see cref="P:Rebus.Testing.FakeBus.PublishedMessages"/>
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Defer(System.TimeSpan,System.Object)">
            <summary>
            Stores the message in the list of deferred messages: <see cref="P:Rebus.Testing.FakeBus.DeferredMessages"/>
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.AttachHeader(System.Object,System.String,System.String)">
            <summary>
            Stores information about the attached header in the list of header attachments made: <see cref="P:Rebus.Testing.FakeBus.AttachedHeaders"/>
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.GetAttachedHeaders(System.Object)">
            <summary>
            Accesses the accumulated list of attached headers for one specific message.
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeBus.Dispose">
            <summary>
            Doesn't do anything
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.Advanced">
            <summary>
            Would have accessed the advanced API, but the FakeBus does not support advanced operations (yet... it might, sometime in the future)
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.SentMessages">
            <summary>
            Accesses the accumulated list of sent messages.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.PublishedMessages">
            <summary>
            Accesses the accumulated list of published messages.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.LocallySentMessages">
            <summary>
            Accesses the accumulated list messages sent to self.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.Replies">
            <summary>
            Accesses the accumulated list of replies sent.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.Subscriptions">
            <summary>
            Accesses the accumulated list of subscriptions made.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.Unsubscriptions">
            <summary>
            Accesses the accumulated list of unsubscriptions made.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.DeferredMessages">
            <summary>
            Accesses the accumulated list of messages deferred to the future.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.AttachedHeaders">
            <summary>
            Accesses the accumulated list of attached headers.
            </summary>
        </member>
        <member name="T:Rebus.Testing.FakeBus.DeferredMessage">
            <summary>
            Contains information about a message deferred to the future.
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.DeferredMessage.Message">
            <summary>
            Gets the message that was deferred
            </summary>
        </member>
        <member name="P:Rebus.Testing.FakeBus.DeferredMessage.Delay">
            <summary>
            Gets the delay by which this message was deferred
            </summary>
        </member>
        <member name="T:Rebus.Testing.SagaFixture`1">
            <summary>
            Saga fixture that can help unit testing sagas.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.#ctor(Rebus.Saga{`0})">
            <summary>
            Constructs the fixture with the given saga handler and the given saga data initially available. Saga data
            instances are cloned.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.#ctor(System.Collections.Generic.IEnumerable{Rebus.Saga{`0}})">
            <summary>
            Constructs the fixture with the given saga handlers and the given saga data initially available. Saga data
            instances are cloned.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.Handle``1(``0)">
            <summary>
            Dispatches a message to the saga, raising the appropriate events along the way.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.AddSagaData(`0)">
            <summary>
            Adds the given saga data to the underlying persister. Please note that the usual uniqueness constraint cannot be enforced
            when adding saga data this way, simply because it is impossible to know at this point which properties are correlation
            properties.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.AddSagaData(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the saga data from the given sequence to the underlying persister. Please note that the usual uniqueness constraint cannot be enforced
            when adding saga data this way, simply because it is impossible to know at this point which properties are correlation
            properties.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.AddSagaData(`0[])">
            <summary>
            Adds the saga data from the given sequence to the underlying persister. Please note that the usual uniqueness constraint cannot be enforced
            when adding saga data this way, simply because it is impossible to know at this point which properties are correlation
            properties.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.Add(`0)">
            <summary>
            Adds the given saga data to the underlying persister. Please note that the usual uniqueness constraint cannot be enforced
            when adding saga data this way, simply because it is impossible to know at this point which properties are correlation
            properties.
            </summary>
        </member>
        <member name="M:Rebus.Testing.SagaFixture`1.GetEnumerator">
            <summary>
            Enumerates all persistent saga data
            </summary>
        </member>
        <member name="P:Rebus.Testing.SagaFixture`1.AvailableSagaData">
            <summary>
            Gets a list of all the saga data that is currently persisted
            </summary>
        </member>
        <member name="P:Rebus.Testing.SagaFixture`1.DeletedSagaData">
            <summary>
            Gets a list of all the saga data that has been marked as complete
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.Exception">
            <summary>
            Raised when the handling of an incoming message gives rise to an exception. When you add a listener to this event,
            the exception will be considered "handled" - i.e. it will not be re-thrown by the saga fixture.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.CorrelatedWithExistingSagaData">
            <summary>
            Raised during message dispatch when the message could be correlated with an existing saga data instance.
            The event is raised before the message is handled by the saga.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.CreatedNewSagaData">
            <summary>
            Raised during message dispatch when the message could not be correlated with an existing saga data instance
            and a new saga data instance was created. The event is raised before the message is handled by the saga.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.CouldNotCorrelate">
            <summary>
            Raised during message dispatch when the message could not be correlated with a saga data instance, and 
            creating a new saga data instance was not allowed.
            </summary>
        </member>
        <member name="E:Rebus.Testing.SagaFixture`1.MarkedAsComplete">
            <summary>
            Raised when the message gives rise to the saga being marked as complete.
            </summary>
        </member>
        <member name="P:Rebus.Testing.SagaFixture`1.Data">
            <summary>
            Gives access to the currently correlated piece of saga data. If none could be correlated, 
            null is returned.
            </summary>
        </member>
        <member name="T:Rebus.Testing.SagaFixture`1.CorrelatedWithExistingSagaDataEventHandler`1">
            <summary>
            Delegate type that can be used to define events of when an incoming message can be correlated with an existing piece of saga data
            </summary>
        </member>
        <member name="T:Rebus.Testing.SagaFixture`1.CreatedNewSagaDataEventHandler`1">
            <summary>
            Delegate type that can be used to define events of when an incoming message gives rise to a new instance of saga data
            </summary>
        </member>
        <member name="T:Rebus.Testing.SagaFixture`1.MarkedAsCompleteEventHandler`1">
            <summary>
            Delegate type that can be used to detect when an incoming message gives rise to a saga data being marked as complete
            </summary>
        </member>
        <member name="T:Rebus.Testing.SagaFixture`1.DeletedEventHandler`1">
            <summary>
            Delegate type that can be used to detect when a persistent instance of saga data has been deleted
            </summary>
        </member>
        <member name="T:Rebus.Testing.SagaFixture`1.ExceptionEventHandler">
            <summary>
            Delegate type that can be used to define events of when handling an incoming message results in an exception
            </summary>
        </member>
        <member name="T:Rebus.Testing.SagaFixture`1.CouldNotCorrelateEventHandler">
            <summary>
            Delegate type that can be used to define events of when an incoming message could have been handled by a saga handler but
            could not be correlated with an existing piece of saga data and it wasn't allowed to initiate a new saga
            </summary>
        </member>
        <member name="T:Rebus.TimedExtensions">
            <summary>
            Extends all types with the ability to be amplified to a <see cref="T:Rebus.Timed`1"/>
            </summary>
        </member>
        <member name="M:Rebus.TimedExtensions.At``1(``0,System.DateTime)">
            <summary>
            Gets a timed value representation of the specified value at the specified time
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.GZipHelper.Compress(System.Byte[])">
            <summary>
            Compresses the given byte array
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.GZipHelper.Decompress(System.Byte[])">
            <summary>
            Decompresses the given byte array
            </summary>
        </member>
        <member name="T:Rebus.Transports.Encrypted.EncryptionAndCompressionConfigurationExtensions">
            <summary>
            Configuration extensions for configuring the transport decorator <see cref="T:Rebus.Transports.Encrypted.EncryptionAndCompressionTransportDecorator"/>
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.EncryptionAndCompressionConfigurationExtensions.CompressMessageBodies(Rebus.Configuration.DecoratorsConfigurer)">
            <summary>
            Configures that message bodies should be compressed in the event that the body size exceeds the default
            threshold of 2048 bytes.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.EncryptionAndCompressionConfigurationExtensions.CompressMessageBodies(Rebus.Configuration.DecoratorsConfigurer,System.Int32)">
            <summary>
            Configures that message bodies should be compressed in the event that the body size exceeds the specified 
            threshold in bytes.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.EncryptionAndCompressionConfigurationExtensions.EncryptMessageBodies(Rebus.Configuration.DecoratorsConfigurer,System.String)">
            <summary>
            Configures that message bodies should be encrypted/decrypted with the specified base 64-encoded key
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.EncryptionAndCompressionConfigurationExtensions.EncryptMessageBodies(Rebus.Configuration.DecoratorsConfigurer)">
            <summary>
            Configures that message bodies should be encrypted/decrypted with a base 64-encoded key from the
            &lt;rijndael&gt; element in the Rebus configuration section
            </summary>
        </member>
        <member name="T:Rebus.Configuration.HelpText">
            <summary>
            Can be used to store code snippets meant to be shown in error messages. Embedded code snippets should be replaced
            by usage of consts from this class.
            </summary>
        </member>
        <member name="F:Rebus.Configuration.HelpText.TransportConfigurationExample">
            <summary>
            Shows a very basic and explicit example on how Rebus can be configured to use MSMQ.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.LoggingConfigurer">
            <summary>
            Configurer that allows for logging to be configured
            </summary>
        </member>
        <member name="M:Rebus.Configuration.LoggingConfigurer.Use(Rebus.Logging.IRebusLoggerFactory)">
            <summary>
            Passes the specified <see cref="T:Rebus.Logging.IRebusLoggerFactory"/> to the backbone
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RebusConfigurer">
            <summary>
            Root configurer that allows for invoking configurers for each aspect of Rebus
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurer.Events(System.Action{Rebus.IRebusEvents})">
            <summary>
            Invokes the configurer that allows for hooking into Rebus' events
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurer.Decorators(System.Action{Rebus.Configuration.DecoratorsConfigurer})">
            <summary>
            Invokes the configurer that allows for setting up decoration steps which will be called before the bus in
            created
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurer.Transport(System.Action{Rebus.Configuration.RebusTransportConfigurer})">
            <summary>
            Invokes the configurer that allows for configuring how Rebus sends and received messages
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurer.Timeouts(System.Action{Rebus.Configuration.RebusTimeoutsConfigurer})">
            <summary>
            Configures how message deferral is handlers - i.e. who will get the <see cref="T:Rebus.Messages.TimeoutRequest"/> when
            Rebus needs to defer a message to the future
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurer.Serialization(System.Action{Rebus.Configuration.RebusSerializationConfigurer})">
            <summary>
            Invokes the configurer that allows for configuring how Rebus serializes transport messages
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurer.Sagas(System.Action{Rebus.Configuration.RebusSagasConfigurer})">
            <summary>
            Invokes the configurer that allows for configuring how Rebus should store sagas
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurer.Subscriptions(System.Action{Rebus.Configuration.RebusSubscriptionsConfigurer})">
            <summary>
            Invokes the configurer that allows for configuring how Rebus should store subscriptions
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurer.MessageOwnership(System.Action{Rebus.Configuration.RebusRoutingConfigurer})">
            <summary>
            Invokes the configurer that allows for configuring how Rebus does routing, which essentially can
            be boiled down to one single question: which endpoint owns a particular message type
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurer.Behavior(System.Action{Rebus.Configuration.RebusBehaviorConfigurer})">
            <summary>
            Invokes the configurer that allows for customizing various behavioral aspects
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurer.SpecifyOrderOfHandlers(System.Action{Rebus.Configuration.PipelineInspectorConfigurer})">
            <summary>
            Invokes the configurer that allows for fluently configuring a filter for Rebus' message handler pipeline
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurer.CreateBus">
            <summary>
            Creates the bus by using all the configured implementations from the backbone, running configured decoration
            steps
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RebusConfigurerWithLogging">
            <summary>
            Extended root configurer that allows for configuring how all internal Rebus components do their logging
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurerWithLogging.Logging(System.Action{Rebus.Configuration.LoggingConfigurer})">
            <summary>
            Invokes the configurer that allows for configuring how Rebus does its logging
            </summary>
        </member>
        <member name="T:Rebus.Configuration.EventsConfigurer">
            <summary>
            Configurer for the various hooks that Rebus provides
            </summary>
        </member>
        <member name="M:Rebus.Configuration.EventsConfigurer.AddUnitOfWorkManager(Rebus.Bus.IUnitOfWorkManager)">
            <summary>
            Adds the specified unit of work manager to the list of managers that get to create units of work for each incoming message
            </summary>
        </member>
        <member name="E:Rebus.Configuration.EventsConfigurer.MessageSent">
            <summary>
            Event that will be raised immediately when the bus is used to send a logical message.
            </summary>
        </member>
        <member name="E:Rebus.Configuration.EventsConfigurer.BeforeMessage">
            <summary>
            Event that will be raised for each received logical message (i.e. it will only be called
            if deserialization completed, and the transport message does in fact contain one or more
            logical messages).
            </summary>
        </member>
        <member name="E:Rebus.Configuration.EventsConfigurer.AfterMessage">
            <summary>
            Event that will be raised for each received logical message (i.e. it will only be called
            if deserialization completed, and the transport message does in fact contain one or more
            logical messages).
            </summary>
        </member>
        <member name="E:Rebus.Configuration.EventsConfigurer.UncorrelatedMessage">
            <summary>
            Event that is raised when an incoming message can be handled by a saga handler, but it
            turns out that no saga data instance could be correlated with the message.
            </summary>
        </member>
        <member name="E:Rebus.Configuration.EventsConfigurer.MessageContextEstablished">
            <summary>
            Event that is raised when an incoming transport message has been properly deserialized,
            and it is about to be dispatched. The message context will last for the duration of the
            message processing and is disposed at the very end.
            </summary>
        </member>
        <member name="E:Rebus.Configuration.EventsConfigurer.BusStarted">
            <summary>
            Event that is raised immediately after the bus starts
            and is ready to handle messages
            </summary>
        </member>
        <member name="E:Rebus.Configuration.EventsConfigurer.BusStopped">
            <summary>
            Event that is raised when the bus is disposed
            </summary>
        </member>
        <member name="E:Rebus.Configuration.EventsConfigurer.BeforeTransportMessage">
            <summary>
            Event that will be raised immediately after receiving a transport 
            message, before any other actions are executed.
            </summary>
        </member>
        <member name="E:Rebus.Configuration.EventsConfigurer.AfterTransportMessage">
            <summary>
            Event that will be raised after a transport message has been handled.
            If an error occurs, the caught exception will be passed to the
            listeners. If no errors occur, the passed exception will be null.
            </summary>
        </member>
        <member name="E:Rebus.Configuration.EventsConfigurer.PoisonMessage">
            <summary>
            Event that will be raised whenever it is determined that a message
            has failed too many times.
            </summary>
        </member>
        <member name="P:Rebus.Configuration.EventsConfigurer.MessageMutators">
            <summary>
            Gets the list of message mutators that should be used to mutate incoming/outgoing messages.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RebusRoutingConfigurer">
            <summary>
            Configurer that allows for configuring which implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/> that should be used
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusRoutingConfigurer.Use(Rebus.IDetermineMessageOwnership)">
            <summary>
            Uses the specified implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/> to determine who owns messages
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusRoutingConfigurer.FromNServiceBusConfiguration">
            <summary>
            Configures Rebus to pick up endpoint mappings in NServiceBus format from the current app.config/web.config.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusRoutingConfigurer.FromRebusConfigurationSection">
            <summary>
            Configures Rebus to expect endpoint mappings to be on Rebus form.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusRoutingConfigurer.FromRebusConfigurationSectionWithFilter(System.Func{System.Type,System.Boolean})">
            <summary>
            Configures Rebus to expect endpoint mappings to be on Rebus form.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RebusSagasConfigurer">
            <summary>
            Configurer that allows for configuring how sagas are made persistent
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSagasConfigurer.Use(Rebus.IStoreSagaData)">
            <summary>
            Uses the specified implementation of <see cref="T:Rebus.IStoreSagaData"/> to persist saga data
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSagasConfigurer.StoreInSqlServer(System.String,System.String,System.String)">
            <summary>
            Configures Rebus to store sagas in SQL Server. Use this overload when your saga doesn't perform
            any additional work in the same SQL Server.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSagasConfigurer.StoreInSqlServer(System.Func{Rebus.Transports.Sql.ConnectionHolder},System.String,System.String)">
            <summary>
            Configures Rebus to store sagas in SQL Server. Use this overload to have the persister use the
            same <see cref="T:System.Data.SqlClient.SqlConnection"/> as you're using, thus enlisting in whatever transactional
            behavior you might be using.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSagasConfigurer.StoreInMemory">
            <summary>
            Configures Rebus to store sagas in memory. This should only be used for very short-lived sagas
            that you can afford to lose on each restart/server crash etc. It's also cool for debugging and
            running stuff locally.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RebusSerializationConfigurer">
            <summary>
            Configurer that allows for configuring which implementation of <see cref="T:Rebus.ISerializeMessages"/> that should be used
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSerializationConfigurer.UseJsonSerializer">
            <summary>
            Configures Rebus to use <see cref="T:Rebus.Serialization.Json.JsonMessageSerializer"/> to serialize messages. A <see cref="T:Rebus.Configuration.JsonSerializationOptions"/>
            object is returned, which can be used to configure detailes around how the JSON serialization should work
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSerializationConfigurer.UseBinarySerializer">
            <summary>
            Configures Rebus to use <see cref="T:Rebus.Serialization.Binary.BinaryMessageSerializer"/> which internally uses the BCL <see cref="T:System.Messaging.BinaryMessageFormatter"/>
            to serialize messages
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSerializationConfigurer.Use(Rebus.ISerializeMessages)">
            <summary>
            Uses the specified implementation of <see cref="T:Rebus.ISerializeMessages"/> to serialize transport messages
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RebusSubscriptionsConfigurer">
            <summary>
            Configurer to configure which kind of subscription storage should be used
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSubscriptionsConfigurer.#ctor(Rebus.Configuration.ConfigurationBackbone)">
            <summary>
            Constructs the confiurer
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSubscriptionsConfigurer.Use(Rebus.IStoreSubscriptions)">
            <summary>
            Uses the specified implementation of <see cref="T:Rebus.IStoreSubscriptions"/> to store
            subscriptions
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSubscriptionsConfigurer.StoreInSqlServer(System.String,System.String)">
            <summary>
            Configures Rebus to use <see cref="T:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage"/> to store subscriptions
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSubscriptionsConfigurer.StoreInMemory">
            <summary>
            Configures Rebus to use <see cref="T:Rebus.Persistence.InMemory.InMemorySubscriptionStorage"/> to store subscriptions
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusSubscriptionsConfigurer.StoreInXmlFile(System.String)">
            <summary>
            Configures Rebus to use <see cref="T:Rebus.Persistence.Xml.XmlSubscriptionStorage"/> to store subscriptions
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RebusTransportConfigurer">
            <summary>
            Configurer to configure which implementations of <see cref="T:Rebus.ISendMessages"/> and <see cref="T:Rebus.IReceiveMessages"/>
            that should be used
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusTransportConfigurer.#ctor(Rebus.Configuration.ConfigurationBackbone)">
            <summary>
            Constructs the configurer
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusTransportConfigurer.UseSender(Rebus.ISendMessages)">
            <summary>
            Uses the specified implementation of <see cref="T:Rebus.ISendMessages"/> to send messages
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusTransportConfigurer.UseReceiver(Rebus.IReceiveMessages)">
            <summary>
            Uses the specified implementation of <see cref="T:Rebus.IReceiveMessages"/> to receive messages
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusTransportConfigurer.UseErrorTracker(Rebus.Bus.IErrorTracker)">
            <summary>
            Uses the specified implementation of <see cref="T:Rebus.Bus.IErrorTracker"/> to track messages between
            failed deliveries
            </summary>
        </member>
        <member name="T:Rebus.BusStartedEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus starts.
            </summary>
        </member>
        <member name="T:Rebus.BusStoppedEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus stops.
            </summary>
        </member>
        <member name="T:Rebus.MessageSentEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus sends a logical message.
            </summary>
        </member>
        <member name="T:Rebus.BeforeMessageEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus received a logical message.
            </summary>
        </member>
        <member name="T:Rebus.AfterMessageEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus received a logical message.
            </summary>
        </member>
        <member name="T:Rebus.BeforeTransportMessageEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus has received a transport message, but it has not yet been deserialized.
            </summary>
        </member>
        <member name="T:Rebus.AfterTransportMessageEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus has received and dispatched a transport message, and then - depending on how that
            went - and exception might be passed along.
            </summary>
        </member>
        <member name="T:Rebus.PoisonMessageEventHandler">
            <summary>
            Delegate type that can listen to whenever the bus has decided that message is poison, and should be moved to the error queue.
            </summary>
        </member>
        <member name="T:Rebus.UncorrelatedMessageEventHandler">
            <summary>
            Delegate type that can listen when an incoming message can be handled by a saga handler, but it turns out that there was no saga data that could be correlated with the message.
            </summary>
        </member>
        <member name="T:Rebus.MessageContextEstablishedEventHandler">
            <summary>
            Delegate type that can listen to whenever a message context is established.
            </summary>
        </member>
        <member name="T:Rebus.IAdvancedBus">
            <summary>
            Extends the capabilities of <see cref="T:Rebus.IBus"/> with some more advanced features.
            </summary>
        </member>
        <member name="P:Rebus.IAdvancedBus.Events">
            <summary>
            Gives access to all the different event hooks that Rebus exposes.
            </summary>
        </member>
        <member name="P:Rebus.IAdvancedBus.Batch">
            <summary>
            Gives access to Rebus' batch operations.
            </summary>
        </member>
        <member name="P:Rebus.IAdvancedBus.Routing">
            <summary>
            Gives access to Rebus' routing operations.
            </summary>
        </member>
        <member name="T:Rebus.Bus.TimeoutReplyHandler">
            <summary>
            Special internal message handler that handles timeout replies from the timeout manager
            </summary>
        </member>
        <member name="T:Rebus.Configuration.DetermineMessageOwnershipFromRebusConfigurationSection">
            <summary>
            Configures endpoint mappings from a <see cref="T:Rebus.Configuration.RebusConfigurationSection"/> configuration section.
            </summary>
        </member>
        <member name="T:Rebus.IDetermineMessageOwnership">
            <summary>
            Should be capable of looking up endpoints from message types - i.e.
            answer the question: "Who owns messages of this type?"
            </summary>
        </member>
        <member name="M:Rebus.IDetermineMessageOwnership.GetEndpointFor(System.Type)">
            <summary>
            Gets the name of the endpoint that is configured to be the owner of the specified message type.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.DetermineMessageOwnershipFromRebusConfigurationSection.#ctor(System.Func{System.Type,System.Boolean})">
            <summary>
            Constructs the endpoint mapper, using the specified type filter to determine whether an encountered
            type should be mapped. Can be used to avoid mapping e.g. factories and stuff if you want to put
            helper classes inside your message assembly
            </summary>
        </member>
        <member name="M:Rebus.Configuration.DetermineMessageOwnershipFromRebusConfigurationSection.#ctor">
            <summary>
            Constructs the endpoint mapper without a type filter
            </summary>
        </member>
        <member name="M:Rebus.Configuration.DetermineMessageOwnershipFromRebusConfigurationSection.GetEndpointFor(System.Type)">
            <summary>
            Gets the name of the endpoint that is configured to be the owner of the specified message type.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.FluentRearrangeHandlersPipelineInspectorBuilder">
            <summary>
            Aids in configuring and adding a <see cref="T:Rebus.Configuration.RearrangeHandlersPipelineInspector"/>.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.FluentRearrangeHandlersPipelineInspectorBuilder.Then``1">
            <summary>
            Configures the <see cref="T:Rebus.Configuration.RearrangeHandlersPipelineInspector"/> to re-arrange the handler
            pipeline, ensuring that the order specified by your calls to <see cref="M:Rebus.Configuration.RearrangeHandlersPipelineInspectorExtensions.First``1(Rebus.Configuration.PipelineInspectorConfigurer)"/>
            and <see cref="M:Rebus.Configuration.FluentRearrangeHandlersPipelineInspectorBuilder.Then``1"/> are respected.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.MappingElement">
            <summary>
            Configuration section for the &lt;endpoints&gt; element
            </summary>
        </member>
        <member name="M:Rebus.Configuration.MappingElement.ToString">
            <summary>
            Gets a nifty string representation of this endpoint mapping
            </summary>
        </member>
        <member name="P:Rebus.Configuration.MappingElement.Messages">
            <summary>
            Gets/sets the value of the messages attribute on the add element
            </summary>
        </member>
        <member name="P:Rebus.Configuration.MappingElement.Endpoint">
            <summary>
            Gets/sets the value of the endpoint attribute on the add element
            </summary>
        </member>
        <member name="P:Rebus.Configuration.MappingElement.IsAssemblyName">
            <summary>
            Gets whether the string stored in <seealso cref="P:Rebus.Configuration.MappingElement.Messages"/> is an assembly name. Otherwise,
            it is a specific type name
            </summary>
        </member>
        <member name="T:Rebus.Configuration.MappingsCollection">
            <summary>
            Configuring collection that can contain a number of <see cref="T:Rebus.Configuration.MappingElement"/>
            </summary>
        </member>
        <member name="M:Rebus.Configuration.MappingsCollection.CreateNewElement">
            <summary>
            Creates a new instance of the <see cref="T:Rebus.Configuration.MappingElement"/>
            </summary>
        </member>
        <member name="M:Rebus.Configuration.MappingsCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            Performs some redundant action because that's just how .NET works
            </summary>
        </member>
        <member name="M:Rebus.Configuration.MappingsCollection.GetEnumerator">
            <summary>
            Performs some redundant action because that's just how .NET works
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RearrangeHandlersPipelineInspectorExtensions">
            <summary>
            Configuration extensions to <see cref="T:Rebus.Configuration.PipelineInspectorConfigurer"/> that creates a fluent API
            for installing and configuring a <see cref="T:Rebus.Configuration.RearrangeHandlersPipelineInspector"/>
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RearrangeHandlersPipelineInspectorExtensions.First``1(Rebus.Configuration.PipelineInspectorConfigurer)">
            <summary>
            Configures the <see cref="T:Rebus.Configuration.RearrangeHandlersPipelineInspector"/> to re-arrange the handler
            pipeline, ensuring that the specified handler type <typeparamref name="THandler"/> is
            executed first, followed by any handlers specified by calling <seealso cref="M:Rebus.Configuration.FluentRearrangeHandlersPipelineInspectorBuilder.Then``1"/>.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RebusConfigurationSection">
            <summary>
            Configuration section for the &lt;rebus&gt; configuration section in app.config/web.config
            </summary>
        </member>
        <member name="F:Rebus.Configuration.RebusConfigurationSection.ExampleSnippetForErrorMessages">
            <summary>
            Gets an example configuration XML snippet that can be used in error messages
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurationSection.VerifyPresenceOfInputQueueConfig">
            <summary>
            Asserts that an input queue name has been configured
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurationSection.VerifyPresenceOfErrorQueueConfig">
            <summary>
            Asserts that an error queue name has been configured
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurationSection.LookItUp">
            <summary>
            Looks up the current AppDomain's Rebus configuration section, throwing
            an explanatory exception if it isn't present
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RebusConfigurationSection.GetConfigurationValueOrDefault``1(System.Func{Rebus.Configuration.RebusConfigurationSection,``0},``0)">
            <summary>
            Helper method that helps getting a value from the Rebus configuration section, allowing for a nifty default to
            be used in cases where the setting in question hasn't been explicitly configured
            </summary>
        </member>
        <member name="P:Rebus.Configuration.RebusConfigurationSection.RijndaelSection">
            <summary>
            Gets the Rijndael encryption configuration section
            </summary>
        </member>
        <member name="P:Rebus.Configuration.RebusConfigurationSection.MappingsCollection">
            <summary>
            Gets the mapping configuration section
            </summary>
        </member>
        <member name="P:Rebus.Configuration.RebusConfigurationSection.InputQueue">
            <summary>
            Gets the input queue name
            </summary>
        </member>
        <member name="P:Rebus.Configuration.RebusConfigurationSection.TimeoutManagerAddress">
            <summary>
            Gets the timeout manager endpoint address
            </summary>
        </member>
        <member name="P:Rebus.Configuration.RebusConfigurationSection.Address">
            <summary>
            Gets this endpoint's address (can be used in cases where e.g. an IP should be used instead of the machine name)
            </summary>
        </member>
        <member name="P:Rebus.Configuration.RebusConfigurationSection.ErrorQueue">
            <summary>
            Gets the error queue name
            </summary>
        </member>
        <member name="P:Rebus.Configuration.RebusConfigurationSection.Workers">
            <summary>
            Gets the number of workers that should be started in this endpoint
            </summary>
        </member>
        <member name="P:Rebus.Configuration.RebusConfigurationSection.MaxRetries">
            <summary>
            Configures how many times a message should be delivered with error before it is moved to the error queue
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RijndaelSection">
            <summary>
            App.config configuration section that allows for configuring an encryption key to be used
            by the Rijndael encryption algorithm
            </summary>
        </member>
        <member name="P:Rebus.Configuration.RijndaelSection.Key">
            <summary>
            Gets the configured key
            </summary>
        </member>
        <member name="T:Rebus.Testing.FakeMessageContext">
            <summary>
            Allows you to establish a fake message context for the duration of a test.
            It should only be necessary to use <see cref="T:Rebus.Testing.FakeMessageContext"/> in places
            where you cannot set up your DI container to automatically inject the current
            <see cref="T:Rebus.IMessageContext"/>.
            In tests where this one is used, you should take care to always call
            <see cref="M:Rebus.Testing.FakeMessageContext.Reset"/> as part of the test teardown logic.
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeMessageContext.Establish(Rebus.IMessageContext)">
            <summary>
            Attaches the specified (most likely mocked) message context to the current thread,
            which will cause <see cref="M:Rebus.MessageContext.GetCurrent"/> to return it.
            </summary>
        </member>
        <member name="M:Rebus.Testing.FakeMessageContext.Reset">
            <summary>
            Removes any attached message contexts from the current thread.
            </summary>
        </member>
        <member name="T:Rebus.IMessageContext">
            <summary>
            This is 
            </summary>
        </member>
        <member name="M:Rebus.IMessageContext.Abort">
            <summary>
            Aborts processing the current message - i.e., after exiting from the
            current handler, no more handlers will be called. Note that this does
            not cause the current transaction to be rolled back.
            </summary>
        </member>
        <member name="P:Rebus.IMessageContext.ReturnAddress">
            <summary>
            Gets the return address of the message that is currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.IMessageContext.RebusTransportMessageId">
            <summary>
            Gets the ID of the message that is currently being handled. This ID is normally provided by 
            Rebus and follows the message if it's forwarded
            </summary>
        </member>
        <member name="P:Rebus.IMessageContext.Items">
            <summary>
            Gets the dictionary of objects associated with this message context. This collection can be used to store stuff
            for the duration of the handling of this transport message.
            </summary>
        </member>
        <member name="E:Rebus.IMessageContext.Disposed">
            <summary>
            Raised when the message context is disposed.
            </summary>
        </member>
        <member name="P:Rebus.IMessageContext.CurrentMessage">
            <summary>
            Returns the logical message currently being handled.
            </summary>
        </member>
        <member name="P:Rebus.IMessageContext.Headers">
            <summary>
            Contains the headers of the transport message currently being handled.
            </summary>
        </member>
        <member name="T:Rebus.InconsistentReturnAddressException">
            <summary>
            Exception that is thrown when a return address header has been added to two or more logical messages in
            a message and the return address is not the same
            </summary>
        </member>
        <member name="M:Rebus.InconsistentReturnAddressException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Mandatory exception ctor
            </summary>
        </member>
        <member name="T:Rebus.InconsistentTimeToBeReceivedException">
            <summary>
            Exception that is thrown when a time-to-be-received header has been added to two or more logical messages in
            a message and the configured time is not the same
            </summary>
        </member>
        <member name="M:Rebus.InconsistentTimeToBeReceivedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Mandatory exception ctor
            </summary>
        </member>
        <member name="T:Rebus.Logging.ColorSetting">
            <summary>
            Represents a console color setting consisting of a foreground and a background color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Foreground(System.ConsoleColor)">
            <summary>
            Sets the foreground color to the specified color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Background(System.ConsoleColor)">
            <summary>
            Sets the background color to the specified color
            </summary>
        </member>
        <member name="M:Rebus.Logging.ColorSetting.Enter">
            <summary>
            Sets the current console colors to those specified in this <see cref="T:Rebus.Logging.ColorSetting"/>,
            restoring them to the previous colors when disposing
            </summary>
        </member>
        <member name="P:Rebus.Logging.ColorSetting.ForegroundColor">
            <summary>
            Gets the foreground color
            </summary>
        </member>
        <member name="P:Rebus.Logging.ColorSetting.BackgroundColor">
            <summary>
            Gets the background color
            </summary>
        </member>
        <member name="T:Rebus.Logging.ConsoleLoggerExtensions">
            <summary>
            Contains extension methods for configuring logging with builtin logging factories.
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.Console(Rebus.Configuration.LoggingConfigurer)">
            <summary>
            Use console stdout for logging (probably only useful for debugging and test scenarios)
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.Console(Rebus.Configuration.LoggingConfigurer,Rebus.Logging.LogLevel)">
            <summary>
            Use console stdout for logging (probably only useful for debugging and test scenarios)
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.ColoredConsole(Rebus.Configuration.LoggingConfigurer)">
            <summary>
            Use colored console stdout for logging (probably only useful for debugging and test scenarios)
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.ColoredConsole(Rebus.Configuration.LoggingConfigurer,Rebus.Logging.LogLevel)">
            <summary>
            Use colored console stdout for logging (probably only useful for debugging and test scenarios)
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.ColoredConsole(Rebus.Configuration.LoggingConfigurer,Rebus.Logging.LoggingColors)">
            <summary>
            Use colored console stdout for logging (probably only useful for debugging and test scenarios)
            and allow the colors to be customized
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.ColoredConsole(Rebus.Configuration.LoggingConfigurer,Rebus.Logging.LoggingColors,Rebus.Logging.LogLevel)">
            <summary>
            Use colored console stdout for logging (probably only useful for debugging and test scenarios)
            and allow the colors to be customized
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.Trace(Rebus.Configuration.LoggingConfigurer)">
            <summary>
            Use the .NET's <see cref="T:System.Diagnostics.Trace"/> for logging.
            </summary>
        </member>
        <member name="M:Rebus.Logging.ConsoleLoggerExtensions.None(Rebus.Configuration.LoggingConfigurer)">
            <summary>
            Disables logging completely. Why would you do that?
            </summary>
        </member>
        <member name="T:Rebus.Logging.ConsoleLoggerFactory">
            <summary>
            Logger factory that logs stuff to the console
            </summary>
        </member>
        <member name="T:Rebus.Logging.ConsoleLoggerFactory.LogStatement">
            <summary>
            One single log statement
            </summary>
        </member>
        <member name="T:Rebus.Bus.SubscriptionMessageHandler">
            <summary>
            Internal message handler that handles subscription messages.
            </summary>
        </member>
        <member name="T:Rebus.Bus.Worker">
            <summary>
            Internal worker thread that continually attempts to receive messages and dispatch to handlers.
            </summary>
        </member>
        <member name="F:Rebus.Bus.Worker.nullMessageReceivedBackoffHelper">
            <summary>
            Helps with waiting an appropriate amount of time when no message is received
            </summary>
        </member>
        <member name="F:Rebus.Bus.Worker.errorThatBlocksOurAbilityToDoUsefulWorkBackoffHelper">
            <summary>
            Helps with waiting an appropriate amount of time when something is wrong that makes us unable to do
            useful work
            </summary>
        </member>
        <member name="F:Rebus.Bus.Worker.dispatchMethodCache">
            <summary>
            Caching of dispatcher methods
            </summary>
        </member>
        <member name="M:Rebus.Bus.Worker.TryProcessIncomingMessage">
            <summary>
            OK - here's how stuff is nested:
            
            - Message queue transaction (TxBomkarl)
                - Before/After transport message
                    - TransactionScope
                        - Before/After logical message
                            Dispatch logical message
            </summary>
        </member>
        <member name="M:Rebus.Bus.Worker.DispatchGeneric``1(``0)">
            <summary>
            Private strongly typed dispatcher method. Will be invoked through reflection to allow
            for some strongly typed interaction from this point and on....
            </summary>
        </member>
        <member name="M:Rebus.Bus.Worker.CreateBackoffHelper(System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary>
            Create a backoff helper that matches the given behavior.
            </summary>
        </member>
        <member name="E:Rebus.Bus.Worker.MessageFailedMaxNumberOfTimes">
            <summary>
            Event that will be raised whenever dispatching a given message has failed MAX number of times
            (usually 5 or something like that).
            </summary>
        </member>
        <member name="E:Rebus.Bus.Worker.UserException">
            <summary>
            Event that will be raised each time message delivery fails.
            </summary>
        </member>
        <member name="E:Rebus.Bus.Worker.SystemException">
            <summary>
            Event that will be raised if an exception occurs outside of user code.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.ConfigurationException">
            <summary>
            Exception that should be thrown in the event that a given configuration is somehow invalid.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.ConfigurationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Mandatory exception ctor
            </summary>
        </member>
        <member name="M:Rebus.Configuration.ConfigurationException.#ctor(System.String,System.Object[])">
            <summary>
            Constructs the exception with the specified message.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.ConfigurationFileFormatException">
            <summary>
            Exception that gets thrown when an error is encountered while attempting to parse out
            an NServiceBus format configuration from the current app.config
            </summary>
        </member>
        <member name="M:Rebus.Configuration.ConfigurationFileFormatException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Mandatory exception ctor
            </summary>
        </member>
        <member name="M:Rebus.Configuration.ConfigurationFileFormatException.#ctor(System.String,System.Object[])">
            <summary>
            Constructs this bad boy!
            </summary>
        </member>
        <member name="T:Rebus.Configuration.PipelineInspectorConfigurer">
            <summary>
            Configurer to configure which kind of pipeline inspector should be installed.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.PipelineInspectorConfigurer.Use(Rebus.IInspectHandlerPipeline)">
            <summary>
            Uses the specified implementation of <see cref="T:Rebus.IInspectHandlerPipeline"/>
            </summary>
        </member>
        <member name="T:Rebus.Configuration.DetermineMessageOwnershipFromNServiceBusEndpointMappings">
            <summary>
            Implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/> that queries the specified XML document
            (loaded from as assembly configuration file or web.config) for endpoint mappings specified on
            the format that NServiceBus understands.
            
            Please note that <see cref="T:Rebus.Configuration.DetermineMessageOwnershipFromNServiceBusEndpointMappings"/> is a tad more
            tolerant than NServiceBus - it does not require that the UnicastBusConfig configuration section
            is declared, even though that is required for NServiceBus to work.
            
            If you for some reason have a configuration section with that name that belongs to another
            framework, then that might be a problem.
            
            If you want to alter the behavior of this implementation, feel free to subclass it and override
            any methods that you see fit.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.DetermineMessageOwnershipFromNServiceBusEndpointMappings.#ctor(Rebus.Configuration.IAppConfigLoader)">
            <summary>
            Constructs the endpoint mapper to use the specified <see cref="T:Rebus.Configuration.IAppConfigLoader"/> to access the app.config
            </summary>
        </member>
        <member name="M:Rebus.Configuration.DetermineMessageOwnershipFromNServiceBusEndpointMappings.GetEndpointFor(System.Type)">
            <summary>
            Gets the owner of the given message type
            </summary>
        </member>
        <member name="M:Rebus.Configuration.DetermineMessageOwnershipFromNServiceBusEndpointMappings.Initialize">
            <summary>
            Initializes the endpoint mapper - will be called once the first time <see cref="M:Rebus.Configuration.DetermineMessageOwnershipFromNServiceBusEndpointMappings.GetEndpointFor(System.Type)"/> is called. This
            method is synchronized, so it will block other threads while initialization is done
            </summary>
        </member>
        <member name="M:Rebus.Configuration.DetermineMessageOwnershipFromNServiceBusEndpointMappings.DoInitialize">
            <summary>
            Carries out the actual initialization
            </summary>
        </member>
        <member name="M:Rebus.Configuration.DetermineMessageOwnershipFromNServiceBusEndpointMappings.ExtractMapping(System.Xml.Linq.XElement)">
            <summary>
            Extracts one single mapping from an encounteret <see cref="T:System.Xml.Linq.XElement"/>
            </summary>
        </member>
        <member name="M:Rebus.Configuration.DetermineMessageOwnershipFromNServiceBusEndpointMappings.AddMappingForType(System.String,System.String)">
            <summary>
            Called when the 'messages' attribute is determined to be for one specific message
            </summary>
        </member>
        <member name="M:Rebus.Configuration.DetermineMessageOwnershipFromNServiceBusEndpointMappings.AddMappingsForAllTypesFromAssemblyNamed(System.String,System.String)">
            <summary>
            Called when the 'messages' attribute is determined to be for an entire assembly
            </summary>
        </member>
        <member name="M:Rebus.Configuration.DetermineMessageOwnershipFromNServiceBusEndpointMappings.Map(System.Type,System.String)">
            <summary>
            Will be called for each type that the endpoint mapper maps to a specific endpoint
            </summary>
        </member>
        <member name="M:Rebus.Configuration.DetermineMessageOwnershipFromNServiceBusEndpointMappings.IsAssemblyName(System.String)">
            <summary>
            Determines whether the given string specifies an assembly name (otherwise, it is assumed to be a specific type)
            </summary>
        </member>
        <member name="T:Rebus.Configuration.IAppConfigLoader">
            <summary>
            Abstracts away how an application's app.config is loaded in a dynamic way
            </summary>
        </member>
        <member name="M:Rebus.Configuration.IAppConfigLoader.LoadIt">
            <summary>
            Loads the AppDomain's current app.config and returns the contents as a string
            </summary>
        </member>
        <member name="T:Rebus.Configuration.RearrangeHandlersPipelineInspector">
            <summary>
            Simple implementation of <see cref="T:Rebus.IInspectHandlerPipeline"/> that is capable of
            ordering handlers.
            </summary>
        </member>
        <member name="T:Rebus.IInspectHandlerPipeline">
            <summary>
            Implement this to hook into the final pipeline of handlers. Possible usage scenarios include
            1) ordering handlers before returning them - e.g. ensure that an authentication handler gets 
            executed before anything else, 2) inspecting the incoming message and cherry-picking handlers 
            depending on the contents of the message.
            
            Note that all handlers will be released - i.e. the Release of <see cref="T:Rebus.IActivateHandlers"/>
            will be called for the union of handlers returned from the GetHandlerInstancesFor method and
            any additional handlers that you may have added to return from the Filter method.
            </summary>
        </member>
        <member name="M:Rebus.IInspectHandlerPipeline.Filter(System.Object,System.Collections.Generic.IEnumerable{Rebus.IHandleMessages})">
            <summary>
            Filter the list of handlers before they get executed.
            </summary>
            <param name="message">The message that is being handled.</param>
            <param name="handlers">This is the sequence of handlers that the <see cref="T:Rebus.IActivateHandlers"/> gave us,
            including any internal handlers that may have been added by Rebus.</param>
            <returns>Your (possibly filtered/re-ordered/completely new) sequence of handlers that will actually end up being executed.</returns>
        </member>
        <member name="F:Rebus.Configuration.RearrangeHandlersPipelineInspector.orders">
            <summary>
            Note that <see cref="T:System.Collections.Generic.Dictionary`2"/> is safe for reading from
            multiple threads. It is assumed that <see cref="M:Rebus.Configuration.RearrangeHandlersPipelineInspector.SetOrder(System.Type[])"/> is called
            during some kind of single-threaded startup phase, whereafter calls to
            the filter method may happen in a re-entrant manner.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RearrangeHandlersPipelineInspector.Filter(System.Object,System.Collections.Generic.IEnumerable{Rebus.IHandleMessages})">
            <summary>
            Implements the filtering operation by attempting to return an ordered sequence of handlers where
            the configured ordering of handler types is respected
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RearrangeHandlersPipelineInspector.SetOrder(System.Type[])">
            <summary>
            Specifies the desired order of handlers. When this is done, RearrangeHandlersPipelineInspector
            will ensure that all handler pipelines containing one or more handlers from <paramref name="handlerTypes"/>
            will be ordered so that these handlers come first, in the order that they are specified. E.g. 
            if <see cref="M:Rebus.Configuration.RearrangeHandlersPipelineInspector.SetOrder(System.Type[])"/> gets called with handlers A, C, and E, and <see cref="M:Rebus.Configuration.RearrangeHandlersPipelineInspector.Filter(System.Object,System.Collections.Generic.IEnumerable{Rebus.IHandleMessages})"/>
            gets called with handlers B, C, A, E, D, the result is A, C, E, B, D. This method should be called only once.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.RearrangeHandlersPipelineInspector.AddToOrder(System.Type)">
            <summary>
            Appends the given type to the order currently stored in the pipeline inspector.
            This method allows this pipeline inspector to be built incrementally, which
            was neede in order to support the fluent configuration API.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.StandardAppConfigLoader">
            <summary>
            <see cref="T:Rebus.Configuration.IAppConfigLoader"/> that can load the application configuration 
            file of the currently activated AppDomain.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.StandardAppConfigLoader.LoadIt">
            <summary>
            Loads the AppDomain's current app.config and returns the contents as a string. If an app.config
            cannot be found, and empty string is returned.
            </summary>
        </member>
        <member name="T:Rebus.Configuration.ThrowingEndpointMapper">
            <summary>
            Endpoint mapper that is meant to be used as the default in cases where
            an implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/> is not chosen.
            It will throw every time it gets called, and it will do so with a nice
            and friendly error message.
            </summary>
        </member>
        <member name="M:Rebus.Configuration.ThrowingEndpointMapper.GetEndpointFor(System.Type)">
            <summary>
            Throws a <see cref="T:Rebus.Configuration.ConfigurationException"/> because this implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/>
            is not meant to be used to actually determine who owns messages - it is installed when the service is set up
            to route all messages explicitly or rely on using the capabilities of a <see cref="T:Rebus.Bus.IMulticastTransport"/>
            </summary>
        </member>
        <member name="T:Rebus.Correlation">
            <summary>
            Represents one single configured correlation between the field from one specified incoming
            message type and one particular field of a piece of saga data
            </summary>
        </member>
        <member name="M:Rebus.Correlation.FieldFromMessage(System.Object)">
            <summary>
            Extracts the relevant field from the given message
            </summary>
        </member>
        <member name="T:Rebus.Correlator`2">
            <summary>
            Element of the fluent syntax used to configure correlations between incoming messages and saga data
            </summary>
        </member>
        <member name="M:Rebus.Correlator`2.CorrelatesWith(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Invokes the final part of the syntax that completes the configuration of this correlation
            </summary>
        </member>
        <member name="T:Rebus.Logging.LoggingColors">
            <summary>
            Represents a set of colors to be used by the <see cref="T:Rebus.Logging.ConsoleLoggerFactory"/> when running
            in colored mode
            </summary>
        </member>
        <member name="M:Rebus.Logging.LoggingColors.#ctor">
            <summary>
            Constructs the default set of logging colors, which if gray, green, yellow, and red foreground for log
            levels debug, info, warn, and error respectively.
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Debug">
            <summary>
            Gets/sets the color to use when printing DEBUG log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Info">
            <summary>
            Gets/sets the color to use when printing INFO log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Warn">
            <summary>
            Gets/sets the color to use when printing WARN log statements
            </summary>
        </member>
        <member name="P:Rebus.Logging.LoggingColors.Error">
            <summary>
            Gets/sets the color to use when printing ERROR log statements
            </summary>
        </member>
        <member name="T:Rebus.Logging.LogLevel">
            <summary>
            Enumeration of the log levels available with Rebus loggers. As a general rule of thumb, levels WARN
            and ERROR should, as a minimum, ALWAYS be logged to a local file or another persistent means.
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Debug">
            <summary>
            Log statement of very low importance which is most likely only relevant in extreme debugging scenarios
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Info">
            <summary>
            Log statement of low importance to unwatched running systems which however can be very relevant when testing and debugging
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Warn">
            <summary>
            Log statement of fairly high importance - always contains relevant information on somewhing that may be a sign that something is wrong
            </summary>
        </member>
        <member name="F:Rebus.Logging.LogLevel.Error">
            <summary>
            Log statement of the highest importance - always contains relevant information on something that has gone wrong
            </summary>
        </member>
        <member name="T:Rebus.Logging.NullLoggerFactory">
            <summary>
            This is the /dev/null of loggers...
            </summary>
        </member>
        <member name="M:Rebus.Logging.NullLoggerFactory.GetLogger(System.Type)">
            <summary>
            Returns a <see cref="T:Rebus.Logging.NullLoggerFactory.NullLogger"/> which is the /dev/null of logging...
            </summary>
        </member>
        <member name="T:Rebus.Logging.TraceLoggerFactory">
            <summary>
            Logger factory that writes log statements using the <see cref="T:System.Diagnostics.Trace"/> API
            </summary>
        </member>
        <member name="M:Rebus.Logging.TraceLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets a <see cref="T:Rebus.Logging.TraceLoggerFactory.TraceLogger"/>
            </summary>
        </member>
        <member name="T:Rebus.Messages.IRebusControlMessage">
            <summary>
            Interface of control bus type messages internal to Rebus (but still external enough that you could provide handlers
            for them and have stuff executed upon receiving them).
            </summary>
        </member>
        <member name="T:Rebus.Messages.TimeoutRequest">
            <summary>
            Requests a delayed reply from the Timeout Service. Upon receiving
            this message, the Timeout Service will calculate the UTC time of when the timeout
            should expire, wait, and then reply with a <see cref="T:Rebus.Messages.TimeoutReply"/>.,
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutRequest.Timeout">
            <summary>
            For how long should the reply be delayed?
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutRequest.CorrelationId">
            <summary>
            Allows for specifying a correlation ID that the Timeout Service will
            return with the <see cref="T:Rebus.Messages.TimeoutReply"/>.
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutRequest.CustomData">
            <summary>
            Allows for additional data to be passed along with the timeout. If you really really want,
            you COULD use this field to pass a serialized object.
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutRequest.SagaId">
            <summary>
            Allows for specifying the ID for the saga requesting the timeout.
            The ID will be returned with the <see cref="T:Rebus.Messages.TimeoutReply"/>.
            </summary>
        </member>
        <member name="T:Rebus.Messages.TimeoutReply">
            <summary>
            This is the reply that the Timeout Service will send back to the
            timeout requestor upon completion of the timeout.
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutReply.DueTime">
            <summary>
            The UTC time of when the timeout expired.
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutReply.CorrelationId">
            <summary>
            The correlation ID as specified in the <see cref="T:Rebus.Messages.TimeoutRequest"/>.
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutReply.SagaId">
            <summary>
            The saga ID as specified in the <see cref="T:Rebus.Messages.TimeoutRequest"/>.
            </summary>
        </member>
        <member name="P:Rebus.Messages.TimeoutReply.CustomData">
            <summary>
            The custom data as specified in the <see cref="T:Rebus.Messages.TimeoutRequest"/>.
            </summary>
        </member>
        <member name="T:Rebus.OptimisticLockingException">
            <summary>
            Exception that gets thrown in cases where a race condition is detected for a piece of saga data.
            </summary>
        </member>
        <member name="M:Rebus.OptimisticLockingException.#ctor(Rebus.ISagaData)">
            <summary>
            Constructs the exception with an error message that explains how a race condition was detected on the specified saga data
            </summary>
        </member>
        <member name="M:Rebus.OptimisticLockingException.#ctor(Rebus.ISagaData,System.Exception)">
            <summary>
            Constructs the exception with an error message that explains how a race condition was detected on the specified saga data,
            supplying as extra information a caught exception
            </summary>
        </member>
        <member name="M:Rebus.OptimisticLockingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Ctor necessary for serialization
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMemory.InMemoryTimeoutStorage">
            <summary>
            Timeout storage that stores timeouts in memory. Please don't use this for anything other than testing stuff,
            e.g. on your developer box and possibly in test environments.
            </summary>
        </member>
        <member name="T:Rebus.Timeout.IStoreTimeouts">
            <summary>
            Abstracts how timeouts are stored and retrieved when they are due. Please note that implementors are required
            to be re-entrant when adding timeouts! Also note that only ONE SINGLE TIMEOUT MANAGER should be using the same timeout storage!
            This is because of the transaction, which goes like this: 
            1) retrieve due timeouts
            2) for each due timeout
            3)      send timeout reply
            4)      remove the due timeout from the storage
            </summary>
        </member>
        <member name="M:Rebus.Timeout.IStoreTimeouts.Add(Rebus.Timeout.Timeout)">
            <summary>
            Should add the specified timeout to the store.
            </summary>
        </member>
        <member name="M:Rebus.Timeout.IStoreTimeouts.GetDueTimeouts">
            <summary>
            Should get all due timeouts. When a timeout has been properly processed, <see cref="M:Rebus.Timeout.DueTimeout.MarkAsProcessed"/>
            should be called, which should cause the timeout to be removed from the underlying data store.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMemory.InMemoryTimeoutStorage.Add(Rebus.Timeout.Timeout)">
            <summary>
            Stores the given timeout in memory
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMemory.InMemoryTimeoutStorage.GetDueTimeouts">
            <summary>
            Retrieves all due timeouts
            </summary>
        </member>
        <member name="T:Rebus.Timeout.DueTimeout">
            <summary>
            Extends a timeout to become a due timeout, which is a timeput that can be marked as processed
            </summary>
        </member>
        <member name="T:Rebus.Timeout.Timeout">
            <summary>
            Represents a timeout 
            </summary>
        </member>
        <member name="M:Rebus.Timeout.Timeout.#ctor(System.String,System.String,System.DateTime,System.Guid,System.String)">
            <summary>
            Constructs the due timeout with the specified values
            </summary>
        </member>
        <member name="M:Rebus.Timeout.Timeout.ToString">
            <summary>
            Gets a nifty string representation of this timeout
            </summary>
        </member>
        <member name="P:Rebus.Timeout.Timeout.ReplyTo">
            <summary>
            Indicates to whom the reply should be sent
            </summary>
        </member>
        <member name="P:Rebus.Timeout.Timeout.CorrelationId">
            <summary>
            Stores a correlation ID to be passed back in the reply
            </summary>
        </member>
        <member name="P:Rebus.Timeout.Timeout.TimeToReturn">
            <summary>
            Stores the UTC time of when to send the reply
            </summary>
        </member>
        <member name="P:Rebus.Timeout.Timeout.SagaId">
            <summary>
            If applicable, stores the ID of the saga that sent the request. Will
            be passed back in the reply
            </summary>
        </member>
        <member name="P:Rebus.Timeout.Timeout.CustomData">
            <summary>
            Stores a piece of custom data - possibly a serialized message to be unpacked
            and delivered by the recipient of the reply
            </summary>
        </member>
        <member name="M:Rebus.Timeout.DueTimeout.#ctor(System.String,System.String,System.DateTime,System.Guid,System.String)">
            <summary>
            COnstructs the timeout
            </summary>
        </member>
        <member name="M:Rebus.Timeout.DueTimeout.MarkAsProcessed">
            <summary>
            Marks the timeout as processed, most likely removing it from the underlying timeout store
            </summary>
        </member>
        <member name="T:Rebus.Logging.RebusLoggerFactory">
            <summary>
            Static gateway that can be used by Rebus components to enlist in the logging framework
            </summary>
        </member>
        <member name="M:Rebus.Logging.RebusLoggerFactory.Reset">
            <summary>
            Resets the current implementation of <see cref="T:Rebus.Logging.IRebusLoggerFactory"/> back to the default, which is a
            <see cref="T:Rebus.Logging.ConsoleLoggerFactory"/> with colors turned ON
            </summary>
        </member>
        <member name="E:Rebus.Logging.RebusLoggerFactory.Changed">
            <summary>
            Event that is raised when the global implementation of <see cref="T:Rebus.Logging.IRebusLoggerFactory"/> is changed to something else.
            Note that the event is also raised immediately for each particular subscriber when they subscribe.
            </summary>
        </member>
        <member name="P:Rebus.Logging.RebusLoggerFactory.Current">
            <summary>
            Gets the currently configured implementation of <see cref="T:Rebus.Logging.IRebusLoggerFactory"/>. The instance is global for the
            entire AppDomain
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerTimeoutStorage">
            <summary>
            Implementaion of <see cref="T:Rebus.Timeout.IStoreTimeouts"/> that uses an SQL Server to store the timeouts
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerTimeoutStorage.#ctor(System.String,System.String)">
            <summary>
            Constructs the timeout storage which will use the specified connection string to connect to a database,
            storing the timeouts in the table with the specified name
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerTimeoutStorage.Add(Rebus.Timeout.Timeout)">
            <summary>
            Adds the given timeout to the table specified by <see cref="P:Rebus.Persistence.SqlServer.SqlServerTimeoutStorage.TimeoutsTableName"/>
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerTimeoutStorage.GetDueTimeouts">
            <summary>
            Queries the underlying table and returns due timeouts, removing them at the same time
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerTimeoutStorage.EnsureTableIsCreated">
            <summary>
            Creates the necessary timeout storage table if it hasn't already been created. If a table already exists
            with a name that matches the desired table name, no action is performed (i.e. it is assumed that
            the table already exists).
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.SqlServerTimeoutStorage.TimeoutsTableName">
            <summary>
            Gets the name of the table where timeouts are stored
            </summary>
        </member>
        <member name="T:Rebus.Persistence.Xml.XmlSubscriptionStorage">
            <summary>
            Class for storing Rebus subscriptions in XML
            </summary>
        </member>
        <member name="T:Rebus.IStoreSubscriptions">
            <summary>
            Implement this in order to affect how subscriptions are stored.
            </summary>
        </member>
        <member name="M:Rebus.IStoreSubscriptions.Store(System.Type,System.String)">
            <summary>
            Saves the association between the given message type and the specified endpoint name.
            </summary>
        </member>
        <member name="M:Rebus.IStoreSubscriptions.Remove(System.Type,System.String)">
            <summary>
            Removes the association between the given message type and the specified endpoint name.
            </summary>
        </member>
        <member name="M:Rebus.IStoreSubscriptions.GetSubscribers(System.Type)">
            <summary>
            Returns the endpoint names for the given message type.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.#ctor(System.String)">
            <summary>
            Creates a new instance of the XmlSubscriptionStorage
            </summary>
            <param name="xmlFilePath">Full path to target XML document. File can exist with existing subscriptions, but will be created if not found. Process must have write access to target directory.</param>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.GetSubscribers(System.Type)">
            <summary>
            Gets the endpoints that are subscribed to the given message type from the configured XML file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.Remove(System.Type,System.String)">
            <summary>
            Removes the endpoint that is subscribed to the given message type from the configured XML file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.Store(System.Type,System.String)">
            <summary>
            Adds the endpoint as a subscriber of the given message type to the configured XML file
            </summary>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.CreateSubscription(System.String,System.String)">
            <summary>
            Creates an XElement from a subscription set
            </summary>
            <param name="subscriberInputQueue">Queue name to store</param>
            <param name="type">Type to use</param>
            <returns>An XElement representing the subscription</returns>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.GetSubscriptionDocument">
            <summary>
            Loads the subscription document from disk if it exists, otherwise creates a new
            </summary>
            <returns>An XDocument with current subscriptions</returns>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.CreateSubscriptionDocument">
            <summary>
            Creates a new (and empty) subscription document
            </summary>
            <returns>An XDocument with no subscriptions</returns>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.GetSubscriptions(System.Xml.Linq.XDocument,System.String)">
            <summary>
            Gets a list of subscriptions
            </summary>
            <param name="doc">XDocument to search for subscriptions in</param>
            <param name="type">Optional type to search for</param>
            <returns>A list of current subscriptions</returns>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.Key(System.Type)">
            <summary>
            Gets the key for a message type
            </summary>
            <param name="t">Type to get key for</param>
            <returns>A key</returns>
        </member>
        <member name="M:Rebus.Persistence.Xml.XmlSubscriptionStorage.ClearAllSubscriptions">
            <summary>
            Clears all subscriptions
            </summary>
        </member>
        <member name="T:Rebus.Persistence.Xml.XmlSubscriptionStorage.Subscription">
            <summary>
            Helper class for subscription entries
            </summary>
        </member>
        <member name="P:Rebus.Persistence.Xml.XmlSubscriptionStorage.Subscription.Type">
            <summary>
            Gets or sets the type
            </summary>
        </member>
        <member name="P:Rebus.Persistence.Xml.XmlSubscriptionStorage.Subscription.Queue">
            <summary>
            Gets or sets the queue name
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Binary.BinaryMessageSerializer">
            <summary>
            Implementation of <see cref="T:Rebus.ISerializeMessages"/> that serializes transport messages with the
            standard BCL <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>
            </summary>
        </member>
        <member name="T:Rebus.ISerializeMessages">
            <summary>
            Implement this to specify how messages are represented as strings.
            </summary>
        </member>
        <member name="M:Rebus.ISerializeMessages.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the specified <see cref="T:Rebus.Messages.Message"/> object into a <see cref="T:Rebus.TransportMessageToSend"/>,
            which is just a container for a headers dictionary and a byte array for the body.
            </summary>
        </member>
        <member name="M:Rebus.ISerializeMessages.Deserialize(Rebus.ReceivedTransportMessage)">
            <summary>
            Deserializes the specified <see cref="T:Rebus.ReceivedTransportMessage"/>, which is a container for a
            headers dictionary, a byte array for the body, and an ID (possibly assigned by the infrastructure),
            into a <see cref="T:Rebus.Messages.Message"/> object.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Binary.BinaryMessageSerializer.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the specified message using the BCL <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Binary.BinaryMessageSerializer.Deserialize(Rebus.ReceivedTransportMessage)">
            <summary>
            Deserializes the specified message using the BCL <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Json.JsonMessageSerializer">
            <summary>
            Implementation of <see cref="T:Rebus.ISerializeMessages"/> that uses Newtonsoft JSON.NET internally to serialize transport messages.
            The used JSON.NET DLL is merged into Rebus, which allows it to be used by Rebus without bothering people by an extra dependency.
            
            JSON.NET has the following license:
            ----------------------------------------------------------------------------------------------------------------------------
            Copyright (c) 2007 James Newton-King
            
            Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation 
            files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, 
            modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software 
            is furnished to do so, subject to the following conditions:
            
            The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
            
            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
            OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS 
            BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF 
            OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
            ----------------------------------------------------------------------------------------------------------------------------
            Bam!1 Thanks James :)
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.JsonMessageSerializer.#ctor">
            <summary>
            Constructs the serializer
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.JsonMessageSerializer.Serialize(Rebus.Messages.Message)">
            <summary>
            Serializes the transport message <see cref="T:Rebus.Messages.Message"/> using JSON.NET and wraps it in a <see cref="T:Rebus.TransportMessageToSend"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.JsonMessageSerializer.Deserialize(Rebus.ReceivedTransportMessage)">
            <summary>
            Deserializes the transport message using JSON.NET from a <see cref="T:Rebus.ReceivedTransportMessage"/> and wraps it in a <see cref="T:Rebus.Messages.Message"/>
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.JsonMessageSerializer.AddNameResolver(System.Func{System.Type,Rebus.Serialization.Json.TypeDescriptor})">
            <summary>
            Adds the specified function to the pipeline of resolvers that can get a <see cref="T:Rebus.Serialization.Json.TypeDescriptor"/>
            from a .NET type. If the function returns null, it means that it doesn't care and the next resulver
            will be called, until ultimately it will fall back to default JSON.NET behavior
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.JsonMessageSerializer.AddTypeResolver(System.Func{Rebus.Serialization.Json.TypeDescriptor,System.Type})">
            <summary>
            Adds the specified function to the pipeline of resolvers that can get a .NET type from a
            <see cref="T:Rebus.Serialization.Json.TypeDescriptor"/>. If the function returns null, it means that it doesn't care and the next resulver
            will be called, until ultimately it will fall back to default JSON.NET behavior
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.JsonMessageSerializer.SpecifyEncoding(System.Text.Encoding)">
            <summary>
            Overrides the default UTF-7 encoding and uses the specified encoding instead when serializing. The used encoding
            is put in a header, so you don't necessarily need to specify the same encoding in order to be able to deserialize
            properly.
            </summary>
        </member>
        <member name="M:Rebus.Serialization.Json.JsonMessageSerializer.SerializeEnumAsStrings(System.Boolean)">
            <summary>
            Configure the serializer to serialize the enums as string.
            </summary>
        </member>
        <member name="T:Rebus.Serialization.Json.JsonMessageSerializer.NonDefaultSerializationBinder">
            <summary>
            JSON.NET serialization binder that can be extended with a pipeline of name and type resolvers,
            allowing for customizing how types are bound
            </summary>
        </member>
        <member name="T:Rebus.SimpleHandlerActivator">
            <summary>
            Very simple implementation of the handler activator that allows a bunch of types to be manually registered,
            either with their type or with a factoryMethod method.
            </summary>
        </member>
        <member name="M:Rebus.SimpleHandlerActivator.Register(System.Type)">
            <summary>
            Registers the given handler type. It is assumed that the type registered has a public
            default constructor - otherwise, instantiation will fail.
            </summary>
        </member>
        <member name="M:Rebus.SimpleHandlerActivator.Register``1(System.Func{``0})">
            <summary>
            Registers a factoryMethod method that is capable of creating a handler instance.
            </summary>
        </member>
        <member name="M:Rebus.SimpleHandlerActivator.Handle``1(System.Action{``0})">
            <summary>
            Registers a function that can handle messages of the specified type.
            </summary>
        </member>
        <member name="M:Rebus.SimpleHandlerActivator.GetHandlerInstancesFor``1">
            <summary>
            Gets all available handlers that can be cast to <see cref="T:Rebus.IHandleMessages`1"/>
            </summary>
        </member>
        <member name="M:Rebus.SimpleHandlerActivator.Release(System.Collections.IEnumerable)">
            <summary>
            Loops throug the given sequence of handler instances and disposes those that implement <see cref="T:System.IDisposable"/>.
            Obviously, this way of disposing dispoables is not as powerful as e.g. Windsor's way of doing it, do you'll
            have to be sure that handlers that YOU know are singletons, are not disposable.
            </summary>
        </member>
        <member name="T:Rebus.RebusTimeMachine">
            <summary>
            Static gateway to the current time. Implements the classic fake time pattern
            found in all the right places. The name is goofy on purpose to avoid colliding with people's own
            Time classes.
            </summary>
        </member>
        <member name="M:Rebus.RebusTimeMachine.Now">
            <summary>
            Gets the current time in UTC.
            </summary>
        </member>
        <member name="M:Rebus.RebusTimeMachine.Today">
            <summary>
            Gets the date of today in UTC.
            </summary>
        </member>
        <member name="T:Rebus.Timed`1">
            <summary>
            Amplifies a <typeparamref name="T"/> with information on a particular time
            </summary>
        </member>
        <member name="M:Rebus.Timed`1.#ctor(System.DateTime,`0)">
            <summary>
            Constructs the timed value
            </summary>
        </member>
        <member name="M:Rebus.Timed`1.op_Implicit(Rebus.Timed{`0})~`0">
            <summary>
            Allows for implicitly casting the amplified type to the encapsulated type
            </summary>
        </member>
        <member name="P:Rebus.Timed`1.Time">
            <summary>
            Gets the time associated with the value
            </summary>
        </member>
        <member name="P:Rebus.Timed`1.Value">
            <summary>
            Gets the value
            </summary>
        </member>
        <member name="T:Rebus.TimeMachine">
            <summary>
            Static gateway to ways of faking the current time. Should only be used in testing scenarios.
            </summary>
        </member>
        <member name="M:Rebus.TimeMachine.FixTo(System.DateTime)">
            <summary>
            Fixes the current time to the specified time which
            should be provided in UTC.
            </summary>
        </member>
        <member name="M:Rebus.TimeMachine.Reset">
            <summary>
            Resets fake time and returns to yielding the actual time.
            </summary>
        </member>
        <member name="T:Rebus.TransportMessageToSend">
            <summary>
            Message container that contains the parts of a single transport message that should be sent.
            It carries a headers dictionary and a body byte array. The <seealso cref="P:Rebus.TransportMessageToSend.Label"/> can be used
            to label the message somehow, which can then be used to show the message if the infrastructure
            supports it.
            </summary>
        </member>
        <member name="M:Rebus.TransportMessageToSend.#ctor">
            <summary>
            Constructs the wrapper of a transport message that is about to be sent
            </summary>
        </member>
        <member name="P:Rebus.TransportMessageToSend.Headers">
            <summary>
            Message headers. Pre-defined header keys can be found in <see cref="T:Rebus.Shared.Headers"/>.
            </summary>
        </member>
        <member name="P:Rebus.TransportMessageToSend.Body">
            <summary>
            Message body. Should not contain any header information.
            </summary>
        </member>
        <member name="P:Rebus.TransportMessageToSend.Label">
            <summary>
            String label to use if the underlying message queue supports it.
            </summary>
        </member>
        <member name="T:Rebus.Serialization.DictionarySerializer">
            <summary>
            Helper that can serialize a dictionary to a string and vice versa
            </summary>
        </member>
        <member name="M:Rebus.Serialization.DictionarySerializer.Serialize(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Serialized the specified dictionary
            </summary>
        </member>
        <member name="M:Rebus.Serialization.DictionarySerializer.Deserialize(System.String)">
            <summary>
            Deserializes the specified string
            </summary>
        </member>
        <member name="T:Rebus.Transports.Encrypted.EncryptionAndCompressionTransportDecorator">
            <summary>
            Decoration for <see cref="T:Rebus.ISendMessages"/> and <see cref="T:Rebus.IReceiveMessages"/> that encrypts/decrypts
            message bodies. When a message is encrypted, the header <see cref="F:Rebus.Shared.Headers.Encrypted"/> is added along
            with the salt used to encrypt the message which is stored in <see cref="F:Rebus.Shared.Headers.EncryptionSalt"/>.
            Only messages with the <see cref="F:Rebus.Shared.Headers.Encrypted"/> header are decrypted.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.EncryptionAndCompressionTransportDecorator.#ctor(Rebus.ISendMessages,Rebus.IReceiveMessages)">
            <summary>
            Constructs the decorator with the specified implementations of <see cref="T:Rebus.ISendMessages"/> and <see cref="T:Rebus.IReceiveMessages"/>,
            storing the specified base 64-encoded key to be used when encrypting/decrypting messages
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.EncryptionAndCompressionTransportDecorator.Send(System.String,Rebus.TransportMessageToSend,Rebus.ITransactionContext)">
            <summary>
            Sends a copy of the specified <see cref="T:Rebus.TransportMessageToSend"/> using the underlying implementation of <see cref="T:Rebus.ISendMessages"/>
            with an encrypted message body and additional headers
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.EncryptionAndCompressionTransportDecorator.ReceiveMessage(Rebus.ITransactionContext)">
            <summary>
            Receives a <see cref="T:Rebus.ReceivedTransportMessage"/> using the underlying implementation of <see cref="T:Rebus.IReceiveMessages"/>
            decrypting the message body if necessary, and remove the additional encryption headers
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.EncryptionAndCompressionTransportDecorator.GenerateKeyBase64">
            <summary>
            Static helper that can be used to generate a brand-spanking-new base 64-encoded encryption key
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.EncryptionAndCompressionTransportDecorator.Dispose">
            <summary>
            Disposes decorated components if they are disposables
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.EncryptionAndCompressionTransportDecorator.EnableEncryption(System.String)">
            <summary>
            Configures the encryption decorator to actually encrypt messages using the specified key
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.EncryptionAndCompressionTransportDecorator.EnableCompression(System.Int32)">
            <summary>
            Configures the encryption decorator to compress message bodies if their size exceeds the
            specified number of bytes.
            </summary>
        </member>
        <member name="P:Rebus.Transports.Encrypted.EncryptionAndCompressionTransportDecorator.InputQueue">
            <summary>
            Gets the simple input queue name from the wrapped implementation of <see cref="T:Rebus.IReceiveMessages"/>
            </summary>
        </member>
        <member name="P:Rebus.Transports.Encrypted.EncryptionAndCompressionTransportDecorator.InputQueueAddress">
            <summary>
            Gets the globally addressable input queue name from the wrapped implementation of <see cref="T:Rebus.IReceiveMessages"/>
            </summary>
        </member>
        <member name="T:Rebus.Transports.Encrypted.RijndaelHelper">
            <summary>
            Encryption helper that encapsulated the Rijndael-specified stuff. Basically just
            gives <see cref="T:System.Security.Cryptography.RijndaelManaged"/> a decent API.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.RijndaelHelper.#ctor(System.String)">
            <summary>
            Constructs the encryption helper, storing the specified key to be used when encrypting/decrypting
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.RijndaelHelper.Encrypt(System.Byte[],System.String)">
            <summary>
            Encrypts the specified buffer using the stored key and the specified salt and returns an encrypted buffer
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.RijndaelHelper.Decrypt(System.Byte[],System.String)">
            <summary>
            Decrypts the specified buffer using the stored key and the specified salt and returns an unencrypted buffer
            </summary>
            <param name="bytes"></param>
            <param name="initializationVector"></param>
            <returns></returns>
        </member>
        <member name="M:Rebus.Transports.Encrypted.RijndaelHelper.GenerateNewKey">
            <summary>
            Generates a new key
            </summary>
        </member>
        <member name="M:Rebus.Transports.Encrypted.RijndaelHelper.GenerateNewIv">
            <summary>
            Generates a new salt
            </summary>
        </member>
        <member name="T:Rebus.Transports.FileSystem.FileSystemMessageQueue">
            <summary>
            Transport implementation that uses the file system to send/receive messages.
            </summary>
        </member>
        <member name="M:Rebus.Transports.FileSystem.FileSystemMessageQueue.#ctor(System.String,System.String)">
            <summary>
            Constructs the file system transport to create "queues" as subdirectories of the specified base directory.
            While it is apparent that <seealso cref="F:Rebus.Transports.FileSystem.FileSystemMessageQueue.baseDirectory"/> must be a valid directory name, please note that 
            <seealso cref="F:Rebus.Transports.FileSystem.FileSystemMessageQueue.inputQueue"/> must not contain any invalid path either.
            </summary>
        </member>
        <member name="M:Rebus.Transports.FileSystem.FileSystemMessageQueue.Sender(System.String)">
            <summary>
            Constructs a special send-only instance of <see cref="T:Rebus.Transports.FileSystem.FileSystemMessageQueue"/>. This instance is meant to be used when Rebus in running in one-way client mode
            </summary>
        </member>
        <member name="M:Rebus.Transports.FileSystem.FileSystemMessageQueue.Send(System.String,Rebus.TransportMessageToSend,Rebus.ITransactionContext)">
            <summary>
            Sends the specified message to the logical queue specified by <seealso cref="!:destinationQueueName"/> by writing
            a JSON serialied text to a file in the corresponding directory. The actual write operation is delayed until
            the commit phase of the queue transaction unless we're non-transactional, in which case it is written immediately.
            </summary>
        </member>
        <member name="M:Rebus.Transports.FileSystem.FileSystemMessageQueue.ReceiveMessage(Rebus.ITransactionContext)">
            <summary>
            Receives the next message from the logical input queue by loading the next file from the corresponding directory,
            deserializing it, deleting it when the transaction is committed.
            </summary>
        </member>
        <member name="M:Rebus.Transports.FileSystem.FileSystemMessageQueue.Initialize">
            <summary>
            Ensures that the "queue" is initialized (i.e. that the corresponding subdirectory exists).
            </summary>
        </member>
        <member name="P:Rebus.Transports.FileSystem.FileSystemMessageQueue.InputQueue">
            <summary>
            Gets the logical input queue name which for this transport correponds to a subdirectory of the specified base directory
            </summary>
        </member>
        <member name="P:Rebus.Transports.FileSystem.FileSystemMessageQueue.InputQueueAddress">
            <summary>
            Gets the logical input queue name which for this transport correponds to a subdirectory of the specified base directory.
            For other transports, this is a global "address", but for this transport the address space is confined to the base directory.
            Therefore, the global address is the same as the input queue name.
            </summary>
        </member>
        <member name="T:Rebus.Transports.FileSystem.FileSystemMessageQueueExtensions">
            <summary>
            Extensions for making it easy to cofigure the file system transport
            </summary>
        </member>
        <member name="M:Rebus.Transports.FileSystem.FileSystemMessageQueueExtensions.UseTheFileSystemInOneWayClientMode(Rebus.Configuration.RebusTransportConfigurer,System.String)">
            <summary>
            Configures Rebus to run in one-way client mode, which means that the bus is capable only of sending messages.
            </summary>
        </member>
        <member name="M:Rebus.Transports.FileSystem.FileSystemMessageQueueExtensions.UseTheFileSystem(Rebus.Configuration.RebusTransportConfigurer,System.String,System.String,System.String)">
            <summary>
            Specifies that you want to use the file system to both send and receive messages. The input queue will be automatically created if it doesn't exist.
            Please note that the file system trans
            </summary>
        </member>
        <member name="M:Rebus.Transports.FileSystem.FileSystemMessageQueueExtensions.UseTheFileSystemAndGetInputQueueNameFromAppConfig(Rebus.Configuration.RebusTransportConfigurer,System.String)">
            <summary>
            Specifies that you want to use the file system to both send and receive messages. The input queue name will be deduced from the Rebus configuration 
            section in the application configuration file. The input queue will be automatically created if it doesn't exist.
            </summary>
        </member>
        <member name="T:Rebus.Transports.Msmq.MsmqConfigurationExtension">
            <summary>
            Configuration extensions that allow for configuring Rebus to use <see cref="T:Rebus.Transports.Msmq.MsmqMessageQueue"/> as a message transport
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqConfigurationExtension.UseMsmq(Rebus.Configuration.RebusTransportConfigurer,System.String,System.String)">
            <summary>
            Specifies that you want to use MSMQ to both send and receive messages. The input
            queue will be automatically created if it doesn't exist.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqConfigurationExtension.UseMsmqInOneWayClientMode(Rebus.Configuration.RebusTransportConfigurer)">
            <summary>
            Configures Rebus to run in one-way client mode, which means that the bus is capable only of sending messages.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqConfigurationExtension.UseMsmqAndGetInputQueueNameFromAppConfig(Rebus.Configuration.RebusTransportConfigurer)">
            <summary>
            Specifies that you want to use MSMQ to both send and receive messages. The input
            queue name will be deduced from the Rebus configuration section in the application
            configuration file. The input queue will be automatically created if it doesn't exist.
            </summary>
        </member>
        <member name="T:Rebus.Transports.OneWayClientGag">
            <summary>
            Dummy implementation of <see cref="T:Rebus.IReceiveMessages"/> that gags the service, causing it
            to experience all kinds of exceptions if it attempts to receive a message.
            </summary>
        </member>
        <member name="M:Rebus.Transports.OneWayClientGag.ReceiveMessage(Rebus.ITransactionContext)">
            <summary>
            The <see cref="T:Rebus.Transports.OneWayClientGag"/> must not accidentally be used, so this operation will throw a <see cref="T:System.InvalidOperationException"/>
            </summary>
        </member>
        <member name="M:Rebus.Transports.OneWayClientGag.StopTracking(System.String)">
            <summary>
            The <see cref="T:Rebus.Transports.OneWayClientGag"/> must not accidentally be used, so this operation will throw a <see cref="T:System.InvalidOperationException"/>
            </summary>
        </member>
        <member name="M:Rebus.Transports.OneWayClientGag.MessageHasFailedMaximumNumberOfTimes(System.String)">
            <summary>
            The <see cref="T:Rebus.Transports.OneWayClientGag"/> must not accidentally be used, so this operation will throw a <see cref="T:System.InvalidOperationException"/>
            </summary>
        </member>
        <member name="M:Rebus.Transports.OneWayClientGag.GetErrorText(System.String)">
            <summary>
            The <see cref="T:Rebus.Transports.OneWayClientGag"/> must not accidentally be used, so this operation will throw a <see cref="T:System.InvalidOperationException"/>
            </summary>
        </member>
        <member name="M:Rebus.Transports.OneWayClientGag.GetPoisonMessageInfo(System.String)">
            <summary>
            The <see cref="T:Rebus.Transports.OneWayClientGag"/> must not accidentally be used, so this operation will throw a <see cref="T:System.InvalidOperationException"/>
            </summary>
        </member>
        <member name="M:Rebus.Transports.OneWayClientGag.SetMaxRetriesFor``1(System.Int32)">
            <summary>
            The <see cref="T:Rebus.Transports.OneWayClientGag"/> must not accidentally be used, so this operation will throw a <see cref="T:System.InvalidOperationException"/>
            </summary>
        </member>
        <member name="M:Rebus.Transports.OneWayClientGag.TrackDeliveryFail(System.String,System.Exception)">
            <summary>
            The <see cref="T:Rebus.Transports.OneWayClientGag"/> must not accidentally be used, so this operation will throw a <see cref="T:System.InvalidOperationException"/>
            </summary>
        </member>
        <member name="P:Rebus.Transports.OneWayClientGag.InputQueue">
            <summary>
            The <see cref="T:Rebus.Transports.OneWayClientGag"/> must not accidentally be used, so this operation will throw a <see cref="T:System.InvalidOperationException"/>
            </summary>
        </member>
        <member name="P:Rebus.Transports.OneWayClientGag.InputQueueAddress">
            <summary>
            The <see cref="T:Rebus.Transports.OneWayClientGag"/> must not accidentally be used, so this operation will throw a <see cref="T:System.InvalidOperationException"/>
            </summary>
        </member>
        <member name="P:Rebus.Transports.OneWayClientGag.ErrorQueueAddress">
            <summary>
            The <see cref="T:Rebus.Transports.OneWayClientGag"/> must not accidentally be used, so this operation will throw a <see cref="T:System.InvalidOperationException"/>
            </summary>
        </member>
        <member name="T:Rebus.Transports.Sql.ConnectionHolder">
            <summary>
            Provides an opened and ready-to-use <see cref="T:System.Data.SqlClient.SqlConnection"/> for doing stuff in SQL Server.
            Construct
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.ConnectionHolder.ForNonTransactionalWork(System.Data.SqlClient.SqlConnection)">
            <summary>
            Constructs a <see cref="T:Rebus.Transports.Sql.ConnectionHolder"/> instance with the given connection. The connection
            will be used for non-transactional work
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.ConnectionHolder.ForTransactionalWork(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlTransaction)">
            <summary>
            Constructs a <see cref="T:Rebus.Transports.Sql.ConnectionHolder"/> instance with the given connection and transaction. The connection
            will be used for transactional work
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.ConnectionHolder.CreateCommand">
            <summary>
            Creates a new <see cref="T:System.Data.SqlClient.SqlCommand"/>, setting the transaction if necessary
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.ConnectionHolder.Dispose">
            <summary>
            Ensures that the ongoing transaction is disposed and the held connection is disposed
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.ConnectionHolder.Commit">
            <summary>
            Commits the transaction if one is present
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.ConnectionHolder.RollBack">
            <summary>
            Rolls back the transaction is one is present
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.ConnectionHolder.GetTableNames">
            <summary>
            Queries sys.Tables in the current DB
            </summary>
        </member>
        <member name="P:Rebus.Transports.Sql.ConnectionHolder.Connection">
            <summary>
            Gets the current open connection to the database
            </summary>
        </member>
        <member name="P:Rebus.Transports.Sql.ConnectionHolder.Transaction">
            <summary>
            Gets the currently ongoing transaction (or null if operating in non-transactional mode)
            </summary>
        </member>
        <member name="T:Rebus.Transports.Sql.SqlServerMessageQueueConfigurationExtension">
            <summary>
            Configuration extensions that allow for configuring Rebus to use <see cref="T:Rebus.Transports.Sql.SqlServerMessageQueue"/> as a message transport
            </summary>
        </member>
        <member name="F:Rebus.Transports.Sql.SqlServerMessageQueueConfigurationExtension.DefaultMessagesTableName">
            <summary>
            Default name of SQL Server table that will be used to store Rebus messages
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.SqlServerMessageQueueConfigurationExtension.UseSqlServer(Rebus.Configuration.RebusTransportConfigurer,System.String,System.String,System.String)">
            <summary>
            Specifies that you want to use MSMQ to both send and receive messages. The input
            queue will be automatically created if it doesn't exist.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.SqlServerMessageQueueConfigurationExtension.UseSqlServerInOneWayClientMode(Rebus.Configuration.RebusTransportConfigurer,System.String)">
            <summary>
            Configures Rebus to run in one-way client mode, which means that the bus is capable only of sending messages.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.SqlServerMessageQueueConfigurationExtension.UseSqlServerAndGetInputQueueNameFromAppConfig(Rebus.Configuration.RebusTransportConfigurer,System.String)">
            <summary>
            Specifies that you want to use MSMQ to both send and receive messages. The input
            queue name will be deduced from the Rebus configuration section in the application
            configuration file. The input queue will be automatically created if it doesn't exist.
            </summary>
        </member>
        <member name="T:Rebus.Transports.Sql.SqlServerMessageQueue">
            <summary>
            SQL Server-based message queue that uses one single table to store all messages. Messages are received in the
            way described here: http://www.mssqltips.com/sqlservertip/1257/processing-data-queues-in-sql-server-with-readpast-and-updlock/
            (which means that the table is queried with a <code>top 1 ... with (updlock, readpast)</code>, allowing for many concurent reads without
            unintentional locking).
            (alternative implementation: http://stackoverflow.com/questions/10820105/t-sql-delete-except-top-1)
            </summary>
        </member>
        <member name="F:Rebus.Transports.Sql.SqlServerMessageQueue.DefaultMessagePriority">
            <summary>
            The default priority that messages will have if the priority has not explicitly been set to something else
            </summary>
        </member>
        <member name="F:Rebus.Transports.Sql.SqlServerMessageQueue.PriorityHeaderKey">
            <summary>
            Special header key that can be used to set the priority of a sent transport message. Please note that the
            priority must be an integer value in the range [0;255] since it is mapped to a tinyint in the database.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.SqlServerMessageQueue.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the SQL Server-based Rebus transport using the specified <paramref name="connectionString"/> to connect to a database,
            storing messages in the table with the specified name, using <paramref cref="F:Rebus.Transports.Sql.SqlServerMessageQueue.inputQueueName"/> as the logical input queue name
            when receiving messages.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.SqlServerMessageQueue.#ctor(System.Func{Rebus.Transports.Sql.ConnectionHolder},System.String,System.String)">
            <summary>
            Constructs the SQL Server-based Rebus transport using the specified factory method to obtain a connection to a database,
            storing messages in the table with the specified name, using <see cref="F:Rebus.Transports.Sql.SqlServerMessageQueue.inputQueueName"/> as the logical input queue name
            when receiving messages.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.SqlServerMessageQueue.Send(System.String,Rebus.TransportMessageToSend,Rebus.ITransactionContext)">
            <summary>
            Sends the specified <see cref="T:Rebus.TransportMessageToSend"/> to the logical queue specified by <paramref name="destinationQueueName"/>.
            What actually happens, is that a row is inserted into the messages table, setting the 'recipient' column to the specified
            queue.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.SqlServerMessageQueue.ReceiveMessage(Rebus.ITransactionContext)">
            <summary>
            Receives a message from the logical queue specified as this instance's input queue. What actually
            happens, is that a row is read and locked in the messages table, whereafter it is deleted.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.SqlServerMessageQueue.EnsureTableIsCreated">
            <summary>
            Creates the message table if a table with that name does not already exist
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.SqlServerMessageQueue.PurgeInputQueue">
            <summary>
            Deletes all the messages from the message table that have the current input queue specified as the recipient
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.SqlServerMessageQueue.Sender(System.String,System.String)">
            <summary>
            Creates a <see cref="T:Rebus.Transports.Sql.SqlServerMessageQueue"/> that is capable of sending only.
            </summary>
        </member>
        <member name="P:Rebus.Transports.Sql.SqlServerMessageQueue.InputQueue">
            <summary>
            Gets the name of this receiver's input queue - i.e. this is the queue that this receiver
            will pull messages from.
            </summary>
        </member>
        <member name="P:Rebus.Transports.Sql.SqlServerMessageQueue.InputQueueAddress">
            <summary>
            Gets the globally accessible adddress of this receiver's input queue - i.e. this would probably
            be the input queue in some form, possible qualified by machine name or something similar.
            </summary>
        </member>
        <member name="T:Rebus.Transports.Sql.SqlServerMessageQueueOptions">
            <summary>
            Options thingie that allows for calling methods of <see cref="T:Rebus.Transports.Sql.SqlServerMessageQueue"/> from the configuration API
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.SqlServerMessageQueueOptions.PurgeInputQueue">
            <summary>
            Deletes all the messages from the message table that have the current input queue specified as the recipient
            </summary>
        </member>
        <member name="M:Rebus.Transports.Sql.SqlServerMessageQueueOptions.EnsureTableIsCreated">
            <summary>
            Creates the message table if a table with that name does not already exist
            </summary>
        </member>
        <member name="T:Rebus.TrivialPipelineInspector">
            <summary>
            The trivial pipeline inspector is an implementation of <see cref="T:Rebus.IInspectHandlerPipeline"/>
            that doesn't actually do anything. It can be used when you don't care about the handler
            pipeline, and then you can switch it for something else some time in the future when you
            feel like it.
            </summary>
        </member>
        <member name="M:Rebus.TrivialPipelineInspector.Filter(System.Object,System.Collections.Generic.IEnumerable{Rebus.IHandleMessages})">
            <summary>
            Returns the unmodified sequence of handlers.
            </summary>
        </member>
        <member name="T:Rebus.IAmInitiatedBy`1">
            <summary>
            Special handler implementation that is allowed to initiate a new saga instance when
            the incoming message cannot be correlated with an existing saga.
            </summary>
            <typeparam name="TMessage">The type of the message being handled. Can be any assignable type as well.</typeparam>
        </member>
        <member name="T:Rebus.ISagaData">
            <summary>
            The minimal interface that must be implemented by a class in order to model the state of a saga.
            The state is of course pretty trivial if you don't extend it with some fields and objects.
            </summary>
        </member>
        <member name="P:Rebus.ISagaData.Id">
            <summary>
            This is the ID of the saga. It should be set in the saga data, e.g. in the constructor
            of the class implementing this interface, ensuring that has been set when the saga
            is persisted the first time.
            </summary>
        </member>
        <member name="P:Rebus.ISagaData.Revision">
            <summary>
            This is the revision of this saga. It may be used by the saga persister to implement
            optimistic locking. Not all saga persisters need to do this though. Please don't mess
            with this one in your code.
            </summary>
        </member>
        <member name="T:Rebus.IStartableBus">
            <summary>
            Represents a bus that wants to be started before it can be used.
            </summary>
        </member>
        <member name="M:Rebus.IStartableBus.Start">
            <summary>
            Starts the bus.
            </summary>
        </member>
        <member name="M:Rebus.IStartableBus.Start(System.Int32)">
            <summary>
            Starts the <see cref="T:Rebus.Bus.RebusBus"/> with the specified number of worker threads.
            </summary>
        </member>
        <member name="T:Rebus.ICanUpdateMultipleSagaDatasAtomically">
            <summary>
            Implement this on a saga persister if it can handle multiple sagas atomically in one transaction.
            </summary>
        </member>
        <member name="T:Rebus.MessageContext">
            <summary>
            Holds information about the message currently being handled on this particular thread.
            </summary>
        </member>
        <member name="M:Rebus.MessageContext.GetCurrent">
            <summary>
            Gets the current thread-bound message context if one is available, throwing an <see cref="T:System.InvalidOperationException"/>
            otherwise. Use <seealso cref="P:Rebus.MessageContext.HasCurrent"/> to check if a message context is available if you're unsure
            </summary>
        </member>
        <member name="M:Rebus.MessageContext.Abort">
            <summary>
            Aborts processing the current message - i.e., after exiting from the
            current handler, no more handlers will be called. Note that this does
            not cause the current transaction to be rolled back.
            </summary>
        </member>
        <member name="M:Rebus.MessageContext.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Rebus.MessageContext.SetLogicalMessage(System.Object)">
            <summary>
            Sets a reference to the logical message that is currently being handled
            </summary>
        </member>
        <member name="M:Rebus.MessageContext.ClearLogicalMessage">
            <summary>
            Clears the reference to the logical message that was being handled
            </summary>
        </member>
        <member name="P:Rebus.MessageContext.Headers">
            <summary>
            Contains the headers dictionary of the transport message currently being handled.
            </summary>
        </member>
        <member name="E:Rebus.MessageContext.Disposed">
            <summary>
            Event that is raised when this message context instance is disposed
            </summary>
        </member>
        <member name="P:Rebus.MessageContext.CurrentMessage">
            <summary>
            Gets a reference to the current logical message being handled
            </summary>
        </member>
        <member name="P:Rebus.MessageContext.RebusTransportMessageId">
            <summary>
            Gets the message ID from the transport message headers
            </summary>
        </member>
        <member name="P:Rebus.MessageContext.ReturnAddress">
            <summary>
            Gets the return address from the transport message headers. This address will most likely be the sender
            of message currently being handled, but it could also have been set explicitly by the sender to another
            endpoint
            </summary>
        </member>
        <member name="P:Rebus.MessageContext.Items">
            <summary>
            Gets the dictionary of objects associated with this message context. This collection can be used to store stuff
            for the duration of the handling of this transport message.
            </summary>
        </member>
        <member name="P:Rebus.MessageContext.HasCurrent">
            <summary>
            Indicates whether a message context is bound to the current thread
            </summary>
        </member>
        <member name="P:Rebus.MessageContext.MessageDispatchAborted">
            <summary>
            Indicates whether message dispatch has been aborted in this message context
            </summary>
        </member>
        <member name="T:Rebus.Shared.Headers">
            <summary>
            Contains keys of headers with special meaning in Rebus.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.Encrypted">
            <summary>
            Specifies that the contents of the message has been encrypted.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.EncryptionSalt">
            <summary>
            Key of header that contains the salt that was used when encrypting this message
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.MessageId">
            <summary>
            Key of header that contains the unique Rebus transport message ID.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.ReturnAddress">
            <summary>
            Key of header that specifies the return address of a message.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.OriginalReturnAddress">
            <summary>
            Key of header that specifies the original return address of a message. This can be used
            to specify the original sender's address in cases where a message is forwarded on another
            service's behalf.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.ErrorMessage">
            <summary>
            Key of header that contains an error message that stems from someone having experienced bad things trying to handle this message.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.Bounced">
            <summary>
            Key of header that flags a message as beign bounced to error queue.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.TimeToBeReceived">
            <summary>
            Key of header that specifies the maximum time a sent/published message is valid. This can/should be used by the infrastructure
            to allow messages to expire when they are no longer relevant.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.SourceQueue">
            <summary>
            Key of source queue name - is attached to poison messages when they are moved to the error queue, allowing
            someone to re-deliver the message when the receiver is ready to retry.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.ContentType">
            <summary>
            Specifies the type of the content included in the body of the message.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.Encoding">
            <summary>
            In the event that the content is some kind of string, this header indicates which encoding was used
            when serializing the string.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.Express">
            <summary>
            Indicates that this message may be delivered faster if it is possible, most likely at the expense of
            delivery guarantee. E.g. a message queue might not durably persist the message when this header is
            added, which might lead to message loss in the event of a server crash.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.Multicast">
            <summary>
            Indicates thats the message will be sent using some kind of multicast protocol. This might lead transport
            implementations to behave differently.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.AutoCorrelationSagaId">
            <summary>
            When a message is sent from within a saga, the saga's ID is attached to the outgoing
            message in order to support auto-correlating replies back to the requesting saga.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.CorrelationId">
            <summary>
            Special header that will flow through message handlers and be automatically transferred to all outgoing messages.
            Will automatically be set to a globally unique ID if it is not present on an outgoing message. Thus it may be
            used to track cause/effect in messaging-based solutions.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.UserName">
            <summary>
            Special header that will flow though message handlers like <see cref="F:Rebus.Shared.Headers.CorrelationId"/>, provided that it is present.
            If not, nothing happens. Thus it may be used to authenticate messages and establish a user context within message handlers.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.Compression">
            <summary>
            This header indicates that the body is currently compressed. The type of the compression is specified by the value.
            </summary>
        </member>
        <member name="T:Rebus.Shared.Headers.CompressionTypes">
            <summary>
            Contains the available compression types.
            </summary>
        </member>
        <member name="F:Rebus.Shared.Headers.CompressionTypes.GZip">
            <summary>
            Indicates that the body has been compressed using GZip
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMemory.InMemorySagaPersister">
            <summary>
            Saga persister that stores saga data in memory. Should probably not be used for anything real, except in scenarios
            where you know the sagas are very short-lived and don't have to be durable. Saga instances are cloned each time they
            are used, so the persister will emulate the workings of durable saga persisters in a fairly realistic manner when used
            concurrently.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMemory.InMemorySagaPersister.AddSagaData(Rebus.ISagaData)">
            <summary>
            Inserts the given saga data WITHOUT ANY SAFETY! So you're on your own with regards to enforcing the unique
            constraing of saga data properties! Why is that? Because at this point, it's impossible to know which
            properties are going to be correlation properties.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMemory.InMemorySagaPersister.Insert(Rebus.ISagaData,System.String[])">
            <summary>
            Stores the saga data in memory, throwing an <see cref="T:Rebus.OptimisticLockingException"/> if the unique constraint
            of correlation properties is violated
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMemory.InMemorySagaPersister.Update(Rebus.ISagaData,System.String[])">
            <summary>
            Updates the given saga data in memory, throwing an <see cref="T:Rebus.OptimisticLockingException"/> if either the unique
            constraint of correlation properties is violated, or if the revision number does not correspond to the 
            "checked out" revision
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMemory.InMemorySagaPersister.Delete(Rebus.ISagaData)">
            <summary>
            Deletes the given saga data, throwing an <see cref="T:Rebus.OptimisticLockingException"/> if it is not present
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMemory.InMemorySagaPersister.Find``1(System.String,System.Object)">
            <summary>
            Looks up an existing saga data instance by looking at the data property at the path specified by
            <paramref name="sagaDataPropertyPath"/> with a value that corresponds to the value specified by <paramref name="fieldFromMessage"/>.
            Note that ToString is called on both, so is assumed that the property pointed to by <paramref name="sagaDataPropertyPath"/>
            and <paramref name="fieldFromMessage"/> both have a valid string representation
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMemory.InMemorySagaPersister.GetEnumerator">
            <summary>
            Gets an enumerator, allowing the underlying saga data instances to be unumerated
            </summary>
        </member>
        <member name="T:Rebus.Persistence.InMemory.InMemorySubscriptionStorage">
            <summary>
            Implementation of <see cref="T:Rebus.IStoreSubscriptions"/> that stores the type -&gt; endpoint mappings in
            an in-memory dictionary
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMemory.InMemorySubscriptionStorage.Store(System.Type,System.String)">
            <summary>
            Stores a subscription for the given message type and the given endpoint in memory
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMemory.InMemorySubscriptionStorage.Remove(System.Type,System.String)">
            <summary>
            Removes the subscription (if any) for the given message type and the given endpoint from memory
            </summary>
        </member>
        <member name="M:Rebus.Persistence.InMemory.InMemorySubscriptionStorage.GetSubscribers(System.Type)">
            <summary>
            Gets from memory an array of endpoints that subscribe to the given message type
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerSagaPersister">
            <summary>
            Implements a saga persister for Rebus that stores sagas as a JSON serialized object in one table
            and correlation properties in an index table on the side.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaPersister.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the persister with the ability to create connections to SQL Server using the specified connection string.
            This also means that the persister will manage the connection by itself, closing it when it has stopped using it.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaPersister.#ctor(System.Func{Rebus.Transports.Sql.ConnectionHolder},System.String,System.String)">
            <summary>
            Constructs the persister with the ability to use an externally provided <see cref="T:System.Data.SqlClient.SqlConnection"/>, thus allowing it
            to easily enlist in any ongoing SQL transaction magic that might be going on. This means that the perister will assume
            that someone else manages the connection's lifetime.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaPersister.Insert(Rebus.ISagaData,System.String[])">
            <summary>
            Inserts the given saga data in the underlying SQL table, generating an appropriate index in the index table for the specified
            correlation properties. In this process, all existing index entries associated with this particular saga data are deleted.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaPersister.Update(Rebus.ISagaData,System.String[])">
            <summary>
            Updates the given saga data in the underlying SQL table, generating an appropriate index in the index table for the specified
            correlation properties. In this process, all existing index entries associated with this particular saga data are deleted.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaPersister.Delete(Rebus.ISagaData)">
            <summary>
            Deletes the saga data instance from the underlying SQL table
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaPersister.Find``1(System.String,System.Object)">
            <summary>
            Queries the underlying SQL table for the saga whose correlation field has a value
            that matches the given field from the incoming message.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaPersister.EnsureTablesAreCreated">
            <summary>
            Creates the necessary saga storage tables if they haven't already been created. If a table already exists
            with a name that matches one of the desired table names, no action is performed (i.e. it is assumed that
            the tables already exist).
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSagaPersister.DoNotIndexNullProperties">
            <summary>
            Configures the persister to ignore null-valued correlation properties and not add them to the saga index.
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.SqlServerSagaPersister.SagaIndexTableName">
            <summary>
            Returns the name of the table used to store correlation properties of saga instances
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.SqlServerSagaPersister.SagaTableName">
            <summary>
            Returns the name of the table used to store JSON serializations of saga instances.
            </summary>
        </member>
        <member name="T:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage">
            <summary>
            Implements a subscriotion storage for Rebus that will store subscriptions in an SQL Server.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.#ctor(System.String,System.String)">
            <summary>
            Constructs the storage with the ability to create connections to SQL Server using the specified connection string.
            This also means that the storage will manage the connection by itself, closing it when it has stopped using it.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.#ctor(System.Func{Rebus.Transports.Sql.ConnectionHolder},System.String)">
            <summary>
            Constructs the storage with the ability to use an externally provided <see cref="T:System.Data.SqlClient.SqlConnection"/>, thus allowing it
            to easily enlist in any ongoing SQL transaction magic that might be going on. This means that the storage will assume
            that someone else manages the connection's lifetime.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.Store(System.Type,System.String)">
            <summary>
            Stores a subscription for the given message type and the given subscriber endpoint in the underlying SQL table.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.Remove(System.Type,System.String)">
            <summary>
            Removes the subscription (if any) for the given message type and subscriber endpoint from the underlying SQL table.
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.GetSubscribers(System.Type)">
            <summary>
            Queries the underlying table for subscriber endpoints that are subscribed to the given message type
            </summary>
        </member>
        <member name="M:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.EnsureTableIsCreated">
            <summary>
            Creates the necessary subscripion storage table if it hasn't already been created. If a table already exists
            with a name that matches the desired table name, no action is performed (i.e. it is assumed that
            the table already exists).
            </summary>
        </member>
        <member name="P:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage.SubscriptionsTableName">
            <summary>
            Returns the name of the table used to store subscriptions
            </summary>
        </member>
        <member name="T:Rebus.Saga">
            <summary>
            Saga base class that allows for passing around non-generic references to saga handlers
            </summary>
        </member>
        <member name="M:Rebus.Saga.#ctor">
            <summary>
            Sets up the internal dictionary of correlations in the saga
            </summary>
        </member>
        <member name="M:Rebus.Saga.ConfigureHowToFindSaga">
            <summary>
            Should fill the internally stored dictionary of correlations by invoking the nifty
            <code>Incoming&lt;TMessage&gt;(m => m.MessageProperty).CorrelatesWith(d => d.SagaDataProperty);</code>
            syntax.
            </summary>
        </member>
        <member name="P:Rebus.Saga.IsNew">
            <summary>
            Indicates whether the saga data instance mounted on this saga handler is new (i.e. it is not yet persistent)
            </summary>
        </member>
        <member name="T:Rebus.Saga`1">
            <summary>
            Extends <see cref="T:Rebus.Saga"/> with type information that specifies which kind of saga data this saga uses to represent its state
            </summary>
        </member>
        <member name="M:Rebus.Saga`1.Incoming``1(System.Func{``0,System.Object})">
            <summary>
            Starts building a correlation expression
            </summary>
        </member>
        <member name="M:Rebus.Saga`1.MarkAsComplete">
            <summary>
            Marks the saga as complete, which results in the saga data effectively being deleted
            </summary>
        </member>
        <member name="P:Rebus.Saga`1.Data">
            <summary>
            Gives access to the current saga data instance
            </summary>
        </member>
        <member name="T:Rebus.ReceivedTransportMessage">
            <summary>
            Message container that contains the received parts of a single transport message.
            It carries a headers dictionary, a body byte array, and an ID which is
            most like assigned by the infrastructure. The ID is used to track retries in the event that
            delivery fails.
            </summary>
        </member>
        <member name="M:Rebus.ReceivedTransportMessage.#ctor">
            <summary>
            Constructs the wrapper of a transport message that has been received
            </summary>
        </member>
        <member name="M:Rebus.ReceivedTransportMessage.ToForwardableMessage">
            <summary>
            Converts this message into a forwardable <see cref="T:Rebus.TransportMessageToSend"/>.
            </summary>
        </member>
        <member name="M:Rebus.ReceivedTransportMessage.GetStringHeader(System.String)">
            <summary>
            Gets the header with the specified key as a string if possible, otherwise null
            </summary>
        </member>
        <member name="P:Rebus.ReceivedTransportMessage.Id">
            <summary>
            Id given to this message, most likely by the queue infrastructure.
            It is important that the message can be uniquely identified - otherwise
            message retry will not be able to recognize the message between retries.
            </summary>
        </member>
        <member name="P:Rebus.ReceivedTransportMessage.Headers">
            <summary>
            Message headers. Pre-defined header keys can be found in <see cref="T:Rebus.Shared.Headers"/>.
            </summary>
        </member>
        <member name="P:Rebus.ReceivedTransportMessage.Body">
            <summary>
            Message body. Should not contain any header information.
            </summary>
        </member>
        <member name="P:Rebus.ReceivedTransportMessage.Label">
            <summary>
            String label used if the underlying message queue supports it.
            </summary>
        </member>
        <member name="T:Rebus.Transports.Msmq.RebusTransportMessageFormatter">
            <summary>
            MSMQ message formatter that should be capable of properly formatting MSMQ
            messages containins a raw byte stream.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.RebusTransportMessageFormatter.Clone">
            <summary>
            Returns this instance (it has no state)
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.RebusTransportMessageFormatter.CanRead(System.Messaging.Message)">
            <summary>
            Always returns true - we always want to attempt to read the message
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.RebusTransportMessageFormatter.Write(System.Messaging.Message,System.Object)">
            <summary>
            Writes to the MSMQ message, assuming that the given object is a <see cref="T:Rebus.TransportMessageToSend"/> -
            otherwise, an <see cref="T:System.ArgumentException"/> will be thrown
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.RebusTransportMessageFormatter.Read(System.Messaging.Message)">
            <summary>
            Reads the given MSMQ message, wrapping the message in a <see cref="T:Rebus.ReceivedTransportMessage"/>
            </summary>
        </member>
        <member name="T:Rebus.Transports.Msmq.MsmqMessageQueue">
            <summary>
            MSMQ implementation of <see cref="T:Rebus.IDuplexTransport"/> (i.e. both <see cref="T:Rebus.ISendMessages"/> and <see cref="T:Rebus.IReceiveMessages"/>).
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqMessageQueue.Sender">
            <summary>
            Constructs a special send-only instance of <see cref="T:Rebus.Transports.Msmq.MsmqMessageQueue"/>. This instance is
            meant to be used when Rebus in running in one-way client mode
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqMessageQueue.#ctor(System.String,System.Boolean)">
            <summary>
            Constructs the <see cref="T:Rebus.Transports.Msmq.MsmqMessageQueue"/>, using the specified input queue. If the queue does not exist,
            it will attempt to create it. If it already exists, it will assert that the queue is transactional.
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqMessageQueue.ReceiveMessage(Rebus.ITransactionContext)">
            <summary>
            Gets the next transport message from the underlying MSMQ queue, returning null if no message is available. The method
            will block up until 1 second while waiting for the next message
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqMessageQueue.Send(System.String,Rebus.TransportMessageToSend,Rebus.ITransactionContext)">
            <summary>
            Sends the given <see cref="T:Rebus.TransportMessageToSend"/> to the input queue specified by <see cref="F:Rebus.Transports.Msmq.MsmqMessageQueue.inputQueueName"/>
            using MSMQ
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqMessageQueue.PurgeInputQueue">
            <summary>
            Purges the input queue
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqMessageQueue.DeleteInputQueue">
            <summary>
            Deletes the input queue entirely
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqMessageQueue.Dispose">
            <summary>
            Disposes the underlying <see cref="T:System.Messaging.MessageQueue"/> instance
            </summary>
        </member>
        <member name="M:Rebus.Transports.Msmq.MsmqMessageQueue.ToString">
            <summary>
            Generates a nifty string representation of this instance, using the MSMQ path of the input queue
            </summary>
            <returns></returns>
        </member>
        <member name="P:Rebus.Transports.Msmq.MsmqMessageQueue.InputQueueAddress">
            <summary>
            Gets a globally addressable representation of the input queue
            </summary>
        </member>
        <member name="P:Rebus.Transports.Msmq.MsmqMessageQueue.InputQueue">
            <summary>
            Gets the input queue name - this queue name *might* not be globally reachable, use <see cref="P:Rebus.Transports.Msmq.MsmqMessageQueue.InputQueueAddress"/>
            instead of you need a global queue address
            </summary>
        </member>
        <member name="T:Rebus.Bus.RebusBus">
            <summary>
            Implements <see cref="T:Rebus.IBus"/> as Rebus would do it.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.#ctor(Rebus.IActivateHandlers,Rebus.ISendMessages,Rebus.IReceiveMessages,Rebus.IStoreSubscriptions,Rebus.IStoreSagaData,Rebus.IDetermineMessageOwnership,Rebus.ISerializeMessages,Rebus.IInspectHandlerPipeline,Rebus.Bus.IErrorTracker,Rebus.Timeout.IStoreTimeouts,Rebus.Configuration.ConfigureAdditionalBehavior)">
            <summary>
            Constructs the bus with the specified ways of achieving its goals.
            </summary>
            <param name="activateHandlers">The bus will use this to construct handlers for received messages.</param>
            <param name="sendMessages">Will be used to send transport messages when you send, publish, and reply.</param>
            <param name="receiveMessages">Will be used to receive transport messages. If the bus is configured to run with multiple threads, this one should be reentrant.</param>
            <param name="storeSubscriptions">Will be used to store subscription information. Is only relevant if the bus is a publisher, i.e. it publishes messages and other services assume they can subscribe to its messages.</param>
            <param name="storeSagaData">Will be used to store saga data. Is only relevant if one or more handlers are derived from <see cref="T:Rebus.Saga"/>.</param>
            <param name="determineMessageOwnership">Will be used to resolve a destination in cases where the message destination is not explicitly specified as part of a send/subscribe operation.</param>
            <param name="serializeMessages">Will be used to serialize and deserialize transport messages.</param>
            <param name="inspectHandlerPipeline">Will be called to inspect the pipeline of handlers constructed to handle an incoming message.</param>
            <param name="errorTracker">Will be used to track failed delivery attempts.</param>
            <param name="storeTimeouts">Optionally provides an internal timeout manager to be used instead of sending timeout requests to an external timeout manager</param>
            <param name="configureAdditionalBehavior"></param>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Start">
            <summary>
            Starts the bus
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Start(System.Int32)">
            <summary>
            Starts the <see cref="T:Rebus.Bus.RebusBus"/> with the specified number of worker threads.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Send``1(``0)">
            <summary>
            Sends the specified message to the destination as specified by the currently
            used implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/>.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SendLocal``1(``0)">
            <summary>
            Sends the specified message to the bus' own input queue.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Publish``1(``0)">
            <summary>
            Publishes the specified event message to all endpoints that are currently subscribed.
            The publisher should have some kind of <see cref="T:Rebus.IStoreSubscriptions"/> implementation,
            preferably a durable implementation like e.g. <see cref="T:Rebus.Persistence.SqlServer.SqlServerSubscriptionStorage"/>.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Reply``1(``0)">
            <summary>
            Sends a reply back to the sender of the message currently being handled. Can only
            be called when a <see cref="T:Rebus.MessageContext"/> has been established, which happens
            during the handling of an incoming message.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Subscribe``1">
            <summary>
            Sends a subscription request for <typeparamref name="TEvent"/> to the destination as
            specified by the currently used implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/>.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Unsubscribe``1">
            <summary>
            Sends an unsubscription request for <typeparamref name="TEvent"/> to the destination as
            specified by the currently used implementation of <see cref="T:Rebus.IDetermineMessageOwnership"/>.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.SetNumberOfWorkers(System.Int32)">
            <summary>
            Sets the number of workers in this <see cref="T:Rebus.Bus.RebusBus"/> to the specified
            number. The number of workers must be greater than or equal to 0. Blocks
            until the number of workers has been set to <seealso cref="!:newNumberOfWorkers"/>.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Defer(System.TimeSpan,System.Object)">
            <summary>
            Sends the message to the timeout manager, which will send it back after the specified
            time span has elapsed. Note that you must have a running timeout manager for this to
            work.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.AttachHeader(System.Object,System.String,System.String)">
            <summary>
            Attaches to the specified message a header with the given key and value. The header will
            be associated with the message, and will be supplied when the message is sent - even if
            it is sent multiple times.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.GetHeaderFor(System.Object,System.String)">
            <summary>
            Retrives the header from the specified message with the given key. If none is found, null is returned.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.HasHeaderFor(System.Object,System.String)">
            <summary>
            Checks if header from the specified message with the given key is attached.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InternalSend(System.String,System.Collections.Generic.List{System.Object})">
            <summary>
            Core send method. This should be the only place where calls to the bus'
            <see cref="T:Rebus.ISendMessages"/> instance gets called, except for when moving
            messages to the error queue. This method will bundle the specified batch
            of messages inside one single transport message, which it will send.
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.InternalSend(System.String,Rebus.Messages.Message)">
            <summary>
            Internal send method - this one must not change the headers!
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.Dispose">
            <summary>
            Stops all workers, waits until they are stopped, disposes all implementations of abstractions that
            implement <see cref="T:System.IDisposable"/>
            </summary>
        </member>
        <member name="M:Rebus.Bus.RebusBus.ToString">
            <summary>
            Formats this bus instance as "Rebus n", where n is the instance number during the lifetime of this AppDomain
            </summary>
        </member>
        <member name="P:Rebus.Bus.RebusBus.Events">
            <summary>
            Gives access to all the different event hooks that Rebus exposes.
            </summary>
        </member>
        <member name="P:Rebus.Bus.RebusBus.Batch">
            <summary>
            Gives access to Rebus' batch operations.
            </summary>
        </member>
        <member name="P:Rebus.Bus.RebusBus.Routing">
            <summary>
            Gives access to Rebus' routing operations.
            </summary>
        </member>
        <member name="P:Rebus.Bus.RebusBus.Advanced">
            <summary>
            Gain access to more advanced and less commonly used features of the bus
            </summary>
        </member>
        <member name="T:Rebus.Messages.SubscriptionMessage">
            <summary>
            Control bus message which is used to tell someone that 
            the sender wishes to subscribe to a particular message type.
            </summary>
        </member>
        <member name="P:Rebus.Messages.SubscriptionMessage.Type">
            <summary>
            Text description of the message type in question
            </summary>
        </member>
        <member name="P:Rebus.Messages.SubscriptionMessage.Action">
            <summary>
            Indicates whether the specified message type should be subscribed/unsubscribed
            </summary>
        </member>
        <member name="T:Rebus.Messages.SubscribeAction">
            <summary>
            Describes what the subscription message is actually supposed to do.
            </summary>
        </member>
        <member name="F:Rebus.Messages.SubscribeAction.Subscribe">
            <summary>
            Indicates that a subscription shoule be set up
            </summary>
        </member>
        <member name="F:Rebus.Messages.SubscribeAction.Unsubscribe">
            <summary>
            Indicates that a subscription shoule be torn down
            </summary>
        </member>
        <member name="T:Rebus.Messages.Message">
            <summary>
            Message wrapper object that may contain a collection of headers and multiple logical messages.
            </summary>
        </member>
        <member name="M:Rebus.Messages.Message.#ctor">
            <summary>
            Constructs the transport message wrapper
            </summary>
        </member>
        <member name="M:Rebus.Messages.Message.GetHeader(System.String)">
            <summary>
            Gets the string header with the specified key or null if the given key is not present
            or is not a string, Lookup names of pre-defined keys via <see cref="P:Rebus.Messages.Message.Headers"/>.
            </summary>
        </member>
        <member name="M:Rebus.Messages.Message.GetLabel">
            <summary>
            Gets some kind of headline that somehow describes this message. May be used by the queue
            infrastructure to somehow label a message.
            </summary>
        </member>
        <member name="M:Rebus.Messages.Message.ToString">
            <summary>
            Formats the message as a suitable string, which in this case is generated by calling
            <see cref="M:Rebus.Messages.Message.GetLabel"/> - in case that fails, the ERROR message is returned (in short format
            though, but maybe you can use it to determine what went wrong... it really shouldn't happen
            though).
            </summary>
        </member>
        <member name="P:Rebus.Messages.Message.Headers">
            <summary>
            Headers of this message. May include metadata like e.g. the address of the sender.
            </summary>
        </member>
        <member name="P:Rebus.Messages.Message.Messages">
            <summary>
            Collection of logical messages that are contained within this transport message.
            </summary>
        </member>
        <member name="T:Rebus.UnhandledMessageException">
            <summary>
            Exception that is thrown when an incoming message cannot be handled by any handlers. This does
            not include the case where a message cannot be dispatched to a saga because a saga instance
            could not be found.
            </summary>
        </member>
        <member name="M:Rebus.UnhandledMessageException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Mandatory exception ctor
            </summary>
        </member>
        <member name="M:Rebus.UnhandledMessageException.#ctor(System.Object)">
            <summary>
            Constructs the exception with a reference to the message that could not be handled
            </summary>
        </member>
        <member name="P:Rebus.UnhandledMessageException.UnhandledMessage">
            <summary>
            Gets the message that could not be handled
            </summary>
        </member>
    </members>
</doc>
